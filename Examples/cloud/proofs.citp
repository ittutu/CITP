*** -----------------------------------------------------------------------------

goal INV is
|-{CLOUD}
fm forall {S:Sys, I:X$Client, J:X$Client}
*** INV1: If the status of a PC is updated, then the status of the Cloud cannot be free ***
     (true = false
      if statusp(S:Sys, I:X$Client) = updated
         /\ statusc(S:Sys) = free) /\
*** INV2: If the status of a PC is gotval then the status of Cloud cannot be free *** 
     (true = false
      if statusp(S:Sys, I:X$Client) = gotval
         /\ statusc(S:Sys) = free) /\
*** INV3: There cannot be two PCs with the statuses updated and gotval ***
     (true = false
      if statusp(S:Sys, I:X$Client) = updated
         /\ statusp(S:Sys, J:X$Client) = gotval) /\
*** INV4: There cannot be two different PCs with the status gotval *** 
     (true = false
      if (I:X$Client =? J:X$Client) = false
         /\ statusp(S:Sys, J:X$Client) = gotval
         /\ statusp(S:Sys, I:X$Client)= gotval) /\
*** INV5: There cannot be two different PCs with the status updated ***	 
     (true = false
      if (I:X$Client =? J:X$Client) = false
         /\ statusp(S:Sys, J:X$Client) = updated
         /\ statusp(S:Sys, I:X$Client) = updated)
   [metadata "inv"] .
endg

begin proof PI of INV
  ind(S:Sys) conj red
  tc ca red ca red
  imp conj push-all red
  init-all
qed

*** -----------------------------------------------------------------------------
*** INV6: If a PC has the status gotval, then its temporal value is equal to the value of the Cloud ***
*** -----------------------------------------------------------------------------

goal INV6 is
  fm true = false
     if (I:X$Client =? J:X$Client) = false
         /\ statusp(S:Sys, J:X$Client) = gotval
         /\ statusp(S:Sys, I:X$Client) = gotval
     [nonexec metadata "inv4"] .
|-{CLOUD}
  fm forall {S:Sys, I:X$Client}
     tmp(S:Sys, I:X$Client) = valc(S:Sys)
     if statusp(S:Sys, I:X$Client) = gotval
     [metadata "inv6"].
endg

begin proof P6 of INV6
  ind(S:Sys)
  tc red ca red ca red
  imp push-all red
  init-all
  ***
  *** alternatively, we could make the initialization of "inv4" explicit
  ***
  *** init("inv4",(S:Sys <- x#1) ; (I:X$Client <- I#2) ; (J:X$Client <- z#2))
qed

*** -----------------------------------------------------------------------------
*** If the status of a PC is updated, then its value is equal to that of the Cloud ***
*** -----------------------------------------------------------------------------

goal GOAL is
  fm true = false
     if N:Nat <= M:Nat = true /\ M:Nat < N:Nat = true
     [nonexec metadata "lemma-nat"] .
  fm true = false
     if statusp(S:Sys, I:X$Client) = updated
        /\ statusp(S:Sys, J:X$Client) = gotval
     [nonexec metadata "inv3"] .
  fm tmp(S:Sys, I:X$Client) = valc(S:Sys)
     if statusp(S:Sys, I:X$Client) = gotval
     [metadata "inv6"] .
|-{CLOUD}
  fm forall {S:Sys,I:X$Client}
     valp(S:Sys, I:X$Client) = valc(S:Sys)
     if statusp(S:Sys, I:X$Client) = updated
     [metadata "inv7"] .
endg

begin proof PG of GOAL
  ind(S:Sys) red
  tc red ca red ca red ca red
  imp push-all red
  pull("inv6") init-all
  *** alternatively, we could make the initializations of
  *** "lemma-nat" and "inv4" explicit
  ***
  *** @crt(pull("inv6"))
  *** @crt(init("lemma-nat", (M:Nat <- valp(x#1, z#2)) ; (N:Nat <- tmp(x#1, z#2))))
  *** init("inv3", I:X$Client <- I#2 ; J:X$Client <- z#2 ; S:Sys <- x#1)
qed

*** -----------------------------------------------------------------------------
