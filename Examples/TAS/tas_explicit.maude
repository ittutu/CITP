---
--- A mutual exclusion protocol with test&set
---
--- Status lock = open;
--- ...
--- Loop: "Remainder Section"
---  rs: repeat while test&set(lock) = close;
---    "Critical Section"
---  cs: lock := open;
---
--- where test&set(x) atomically does the following:
--- x is set to close and the old value of x is returned.
---
--- Initially, lock is open and each process is in
--- Remainder Section (or at label rs).
---

fmod LABEL is
 sort Label .

 ops rs cs : -> Label [ctor] .
 op _~_ : Label Label -> Bool [comm] .
 eq (L:Label ~ L:Label) = true .
 eq (rs ~ cs) = false .
endfm

fmod PROC is
 pr LABEL .
 pr NAT .

 sort Proc .
 op [_,_] : Nat Label -> Proc [ctor] .
endfm

view Proc from TRIV to PROC is
 sort Elt to Proc .
endv

fmod STATUS is
 sort Status .
 ops open close : -> Status [ctor] .
 op _~_ : Status Status -> Bool [comm] .
 eq (L:Status ~ L:Status) = true .
 eq (open ~ close) = false .
endfm

fmod TAS is
 pr SET{Proc} * (sort Set{Proc} to PSet, op _,_ to __) .
 pr STATUS .

 sorts Reach Sys .
 subsort Reach < Sys .

 op <_,_> : Status PSet -> Sys [ctor] .

 var  S : Status .
 var  L : Label .
 var  PS : PSet .
 var  N : Nat .

 cmb < open, PS > : Reach
  if allRS(PS) [nonexec metadata "ctor-init"] .
 cmb < close, [N, cs] PS > : Reach
  if < open, [N, rs] PS > : Reach [nonexec metadata "ctor-enter"] .
 cmb < open, [N, rs] PS > : Reach
  if < S, [N, cs] PS > : Reach [nonexec metadata "ctor-leave"] .

 op allRS : PSet -> Bool .
 eq allRS(empty) = true .
 eq allRS([N, rs] PS) = allRS(PS) .
 eq allRS([N, cs] PS) = false .
endfm

