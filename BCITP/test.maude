in citp

mod TEST is
    sorts PNat PNzNat Elt .
    subsorts PNzNat < PNat .
  op 0 : -> PNat [ctor].
  op s_ : PNat -> PNat [ctor].
  op _+_ : PNat PNat -> PNat .
  op gcd : PNat PNat -> PNat .
  op d : PNat PNat -> PNat .
  op min : PNat PNat -> PNat .
  ops a a1 a2 b b1 b2 c c1 c2 d d1 d2 g1 g2 f1 f2 e e1 e2 i j : -> Elt .
---
  vars A B : PNat .
  vars A' B' : PNzNat .
---
 eq 0 + A = A .
 eq s A + B = s(A + B).
---
 eq d(s A,s B) = d(A,B).
 eq d(0,A) = A .
 eq d(A,0) = A .
---
 eq min(s A,s B) = s min(A,B).
 eq min(A,0) = 0 .
 eq min(0,A) = 0 .
---
 eq gcd(s A,s B) = gcd(d(s A,s B),min(s A,s B)).
 eq gcd(A,0) = A .
 eq gcd(0,A) = A .
---
 ops g h : Elt -> Elt .
 op f : Elt Elt -> Elt .
 var X : Elt .
 ceq f(a,X) = f(b,X) if g(X) = X /\ h(X) = X .
 ceq g(c) = c if g(d) = g(e) .
 ceq h(c) = c if g(i) = g(j) .
 eq  d = e .
 eq  g(i) = g(j) .


 ceq a1 = a2 if b1 = b2 /\ c1 = c2 .
 ceq b1 = b2 if d1 = d2 .
 ceq c1 = c2 if d1 = d2 .
 ceq d1 = d2 if e1 = e2 .
 ceq e1 = e2 if f1 = f2 /\ g1 = g2 .
 eq f1 = f2 .
 eq g1 = g2 .
---
endm

***(
reduce in #REDUCTION# :
  #applyEq#(upModule('TEST,false),
            eq 'gcd['A:PNat,'B:PNat] = 'gcd['d['A:PNat,'B:PNat],'min['A:PNat,'B:PNat]] [none].,
	    'gcd['s_['s_['s_['s_['0.PNat]]]],'s_['s_['0.PNat]]],
	    0,unbounded,0).
)
reduce in #REDUCTION# :
 #red*#(114,1,114,upModule('TEST,false),
             'gcd['s_['s_['s_['s_['s_['s_['s_['s_['s_['s_['s_['s_['s_['s_['s_['0.PNat]]]]]]]]]]]]]]],'s_['s_['s_['s_['s_['s_['s_['s_['s_['s_['0.PNat]]]]]]]]]]]).


reduce in #REDUCTION# :
 #red*#(1,5,1,upModule('TEST,false), 'a1.Elt).

reduce in #REDUCTION# :
 #red*#(1,3,1,upModule('TEST,false), 'f['a.Elt,'c.Elt]).

red in #REDUCTION# :
 #redStep#(2,1,upModule('TEST,false),
 ceq 'f['a.Elt,'X:Elt] = 'f['b.Elt,'X:Elt] if 'g['X:Elt] = 'X:Elt /\ 'h['X:Elt] = 'X:Elt [none] .,
 'f['a.Elt,'c.Elt]).

red in #REDUCTION# :
 #applyEq#(upModule('TEST,false),
 ceq 'f['a.Elt,'X:Elt] = 'f['b.Elt,'X:Elt] if 'g['X:Elt] = 'X:Elt /\ 'h['X:Elt] = 'X:Elt [none].,
 'f['a.Elt,'c.Elt],
 0,unbounded,0).
