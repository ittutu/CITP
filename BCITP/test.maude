in citp

fmod TEST is
  sorts Elt .
  ops a a1 a2 b b1 b2 c c1 c2 d d1 d2 g1 g2 f1 f2 e e1 e2 i j : -> Elt .
  ops g h : Elt -> Elt .
  op f : Elt Elt -> Elt .
  var X : Elt .
 ceq f(a,X) = f(b,X) if g(X) = X /\ h(X) = X [metadata "lm1"] .
 ceq g(c) = c if g(d) = g(e) .
 ceq h(c) = c if g(i) = g(j) .
 eq  d = e .
 eq  g(i) = g(j) .


 ceq a1 = a2 if b1 = b2 /\ c1 = c2 [metadata "axa"] .
 ceq b1 = b2 if d1 = d2 .
 ceq c1 = c2 if d1 = d2 .
 ceq d1 = d2 if e1 = e2 [metadata "axd"] .
 ceq e1 = e2 if f1 = f2 /\ g1 = g2 .
 eq f1 = f2 [metadata "axf"].
 eq g1 = g2 .
---
endfm

red in #REDUCTION# :
applyEq(< upModule('TEST,false), eq 'a1.Elt = 'a2.Elt [none]; >,
        ceq 'a1.Elt = 'a2.Elt if 'b1.Elt = 'b2.Elt /\ 'c1.Elt = 'c2.Elt [none];,
	'a1.Elt,0,unbounded,0).

select #CITP# .
loop init .

(goal TEST |- eq a1 = a2 ;)

(applyEq ceq a1 = a2 if b1 = b2 /\ c1 = c2 ; to a1 at 0 unbounded 0)
eof


***(
reduce in #REDUCTION# :
  applyEq(upModule('TEST,false),
            eq 'gcd['A:PNat,'B:PNat] = 'gcd['d['A:PNat,'B:PNat],'min['A:PNat,'B:PNat]] [none].,
	    'gcd['s_['s_['s_['s_['0.PNat]]]],'s_['s_['0.PNat]]],
	    0,unbounded,0).

reduce in #REDUCTION# :
 redFin(114,1,114,upModule('TEST,false),
             'gcd['s_['s_['s_['s_['s_['s_['s_['s_['s_['s_['s_['s_['s_['s_['s_['0.PNat]]]]]]]]]]]]]]],'s_['s_['s_['s_['s_['s_['s_['s_['s_['s_['0.PNat]]]]]]]]]]]).


reduce in #REDUCTION# :
 redFin(1,5,1,upModule('TEST,false), 'a1.Elt).

reduce in #REDUCTION# :
 redFin(1,3,1,upModule('TEST,false), 'f['a.Elt,'c.Elt]).
eof
red in #REDUCTION# :
 redStep(2,1,upModule('TEST,false),
 ceq 'f['a.Elt,'X:Elt] = 'f['b.Elt,'X:Elt] if 'g['X:Elt] = 'X:Elt /\ 'h['X:Elt] = 'X:Elt [none] .,
 'f['a.Elt,'c.Elt]).

red in #REDUCTION# :
 applyEq(upModule('TEST,false),
 ceq 'f['a.Elt,'X:Elt] = 'f['b.Elt,'X:Elt] if 'g['X:Elt] = 'X:Elt /\ 'h['X:Elt] = 'X:Elt [none].,
 'f['a.Elt,'c.Elt],
 0,unbounded,0).
)