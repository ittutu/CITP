***( SpeX/Lang/CITP

  This file is part of CITP.

  License : GNU General Public License v2.0 or later (GPL-2.0-or-later)
  Authors : Daniel Gaina <daniel@imi.kyushu-u.ac.jp>,
            Ionut Tutu <Ionut.Tutu@imar.ro>,
            Adrian Riesco <ariesco@fdi.ucm.es>

)

sload ../../Language.maude
sload ./Data.maude
sload ./SpecLang.maude

********************************************************************************

fmod CITP/LANGUAGE is
  protecting CITP/LID .
  protecting GRAMMAR .

  *** declarations  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
  op goal-grammar : CITP -> Grammar .
  eq goal-grammar(CITP)
   = grammar 'CITP/Syntax is
       'Goal
         ::= "goal_is |-{_}_endg" : 'GoalName 'ModuleName 'FormDeclList
             [format ('! 'so 's! 'on! 'o 'd 'd 'n++i 'n--i! 'o)]
          |  "goal_is_|-{_}_endg" : 'GoalName 'FormDeclList 'ModuleName
                                    'FormDeclList
             [format ('! 'so 's! 'on++i 'n--i! 'o 'd 'd 'n++i 'n--i! 'o)]
       'GoalName
         ::= bubble "goalName" [exclude ("is")]
       'ModuleName
         ::= bubble "moduleName" [exclude ("}")]
       'FormDeclList
         ::= just 'FormDecl
          |  "__" : 'FormDeclList 'FormDeclList [assoc format ('d 'ni 'd)]
       'FormDecl
         ::= "fm_." : 'Form [format ('! 'so 's! 'o)]
          |  "fm_[_]." : 'Form 'AttrList [format ('! 'so 's! 'o '! 's 'o)]
       'Form
         ::= bubble "formula"
             [balanced-parentheses exclude ("fm" "[" "]" "|-" "endg")]
       'AttrList
         ::= bubble "attrList" [exclude ("[" "]")]
     endgr .

  *** printing grammar (used for formatting the CITP output)  - - - - - - - - --
  op print-grammar : CITP -> Grammar .
  eq print-grammar(CITP)
   = grammar 'CITP/Syntax is
       *** goals  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  --
       'Goal
         ::= "goal_is |-{_}_endg" : 'GoalName 'ModuleName 'FormDeclList
             [format ('! 'so 's! 'on! 'o 'd 'd 'n++i 'n--i! 'o)]
          |  "goal_is_|-{_}_endg" : 'GoalName 'FormDeclList 'ModuleName
                                    'FormDeclList
             [format ('! 'so 's! 'on++i 'n--i! 'o 'd 'd 'n++i 'n--i! 'o)]
          |  "goal_is |-{_}_endg" : 'GoalName 'MaudeModule 'FormDeclList
             [format ('! 'so 's! 'on! 'o+++ 'd 'd '---n++i 'n--i! 'o)]
          |  "goal_is_|-{_}_endg" : 'GoalName 'FormDeclList 'MaudeModule
                                    'FormDeclList
             [format ('! 'so 's! 'on++i 'n--i! 'o+++ 'd 'd '---n++i 'n--i! 'o)]
       'GoalName
         ::= bubble "goalName" [exclude ("is")]
       'MaudeModule
         ::= "th_is`protecting_._endth" : 'ModuleName 'ModuleName 'MaudeDeclList
             [format ('! 'so 's! 's 'so 's! 'on+++i 'n---i! 'o)]
       'ModuleName
         ::= bubble "moduleName" [exclude ("}")]
       'MaudeDeclList
         ::= just 'MaudeDecl
          |  "__" : 'MaudeDeclList 'MaudeDeclList [assoc format ('d 'ni 'd)]
       'MaudeDecl
         ::= bubble "maude-declaration"
       'FormDeclList
         ::= just 'FormDecl
          |  "__" : 'FormDeclList 'FormDeclList [assoc format ('d 'ni 'd)]
       'FormDecl
         ::= "fm_." : 'Form [format ('! 'so 's! 'o)]
          |  "fm_[_]." : 'Form 'AttrList [format ('! 'so 's! 'o '! 's 'o)]
       'Form
         ::= bubble "formula"
             [balanced-parentheses exclude ("fm" "[" "]" "|-" "endg")]
       'AttrList
         ::= bubble "attrList" [exclude ("[" "]")]
       *** proofs  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -
       'Proof
         ::= "proof_of_is`qed" : 'ProofName 'GoalName
             [format ('! 'so 's! 'so '!s 'on! 'o)]
          |  "proof_of_is_qed" : 'ProofName 'GoalName 'TacticListSeq
             [format ('! 'so 's! 'so '!s 'on++i 'n--i! 'o)]
       'ProofName
         ::= token "proofName"
       'TacticListSeq
         ::= just 'TacticList
          |  "__" : 'TacticListSeq 'TacticListSeq [assoc format ('d 'ni 'd)]
       'TacticList
         ::= bubble "tacticList"
             [balanced-parentheses exclude (".")]
     endgr .

  *** formulas  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
  op fm-grammar : CITP -> Grammar .
  eq fm-grammar(CITP)
   = grammar 'CITP/fm-syntax is
       'Formula
         ::= lit "true" [format('! 'o)]
          |  lit "false" [format('! 'o)]
          |  "_=_" : 'Term 'Term
             [format ('d 's! 'so 'd) prec (51)]
          |  "_:_" : 'Term 'Sort
             [format ('d 's! 'so 'd) prec (51)]
          |  "_:=_" : 'Term 'Term
             [format ('d 's! 'so 'd) prec (51)]
          |  "_=>_" : 'Term 'Term
             [format ('d 's! 'so 'd) prec (51)]
          |  "~_" : 'Formula
             [format ('! 'so 'd) prec (71)]
          |  "_/\\_" : 'Formula 'Formula
             [assoc format ('d 's! 'so 'd) prec (75)]
          |  "_\\/_" : 'Formula 'Formula
             [assoc format ('d 's! 'so 'd) prec (77)]
          |  "_if_" : 'Formula 'Formula
             [format ('d 's! 'so 'd) gather ('E 'e) prec (79)]
          |  "forall{_}_" : 'VarList 'Formula
             [format ('! 's 'o '! 'so 'd) prec (81)]
          |  "exists{_}_" : 'VarList 'Formula
             [format ('! 's 'o '! 'so 'd) prec (81)]
       'Term
         ::= bubble "term"
             [balanced-parentheses
              exclude ("~" "/\\" "\\/" "if" "forall" "exists")]
       'Sort
         ::= token "sort"
       'Variable
         ::= token "variable" [exclude ("{" "}" ",")]
       'VarList
         ::= just 'Variable
          |  "_,_" : 'VarList 'VarList [assoc format ('d '! 'so 'd)]
     endgr .

  *** formula attributes  - - - - - - - - - - - - - - - - - - - - - - - - - - --
  op fm-attr-grammar : CITP -> Grammar .
  eq fm-attr-grammar(CITP)
   = grammar 'CITP/fm-attr-syntax is
       'Attr
         ::= "label_" : 'Label [format ('! 'os 'd)]
          |  "metadata_" : 'Metadata [format ('! 'os 'd)]
          |  lit "owise" [format ('! 'o)]
          |  lit "nonexec" [format ('! 'o)]
       'AttrList
         ::= just 'Attr | "__" : 'AttrList 'AttrList [assoc]
       'Label ::= token "label"
       'Metadata ::= <string>
     endgr .

  *** tactics  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  op tactic-grammar : CITP -> Grammar .
  eq tactic-grammar(CITP)
   = grammar 'CITP/tactic-syntax is
       'TacticList
         ::= just 'Tactic
          |  "__" : 'TacticList 'TacticList [assoc format ('d 's 'd)]
       'Tactic
         ::= lit "split" [format ('! 'o)]
          |  "@crt" : 'TacticList [format ('! 'o)]
          |  lit "simp" [format ('! 'o)]
          |  lit "red" [format ('! 'o)]
          |  lit "imp" [format ('! 'o)]
          |  lit "conj" [format ('! 'o)]
          |  "disj" : 'Number [format ('! 'o)]
          |  "disj" : 'Metadata [format ('! 'o)]
          |  lit "tc" [format ('! 'o)]
          |  lit "sk" [format ('! 'o)]
          |  lit "ca" [format ('! 'o)]
          |  lit "ca-rev" [format ('! 'o)]
          |  lit "cs" [format ('! 'o)]
          |  lit "trans" [format ('! 'o)]
          |  "ind" : 'VarList [format ('! 'o)]
          |  "ind-schema" : 'VarList [format ('! 'o)]
          |  "init" : 'Metadata 'Substitution [format ('! 'o)]
          |  "init" : 'Number 'Substitution [format ('! 'o)]
          |  "init" : 'Metadata [format ('! 'o)]
          |  lit "init-all" [format ('! 'o)]
          |  "subst" : 'Substitution [format ('! 'o)]
          |  "pull" : 'Metadata [format ('! 'o)]
          |  "push" : 'Metadata [format ('! 'o)]
          |  "push" : 'Number [format ('! 'o)]
          |  lit "push-all" [format ('! 'o)]
          |  "select" : 'Number [format ('! 'o)]
          |  lit "pass" [format ('! 'o)]
       'VarList
         ::= just 'Variable
          |  "_,_" : 'VarList 'VarList [assoc format ('d '! 'so 'd)]
       'Variable
         ::= token "variable" [exclude ("{" "}" ",")]
       'Term
         ::= bubble "term"
             [balanced-parentheses
              exclude ("~" "/\\" "\\/" "if" "forall" "exists" ";")]
       'Substitution
         ::= "_<-_" : 'Variable 'Term
             [prec (51) format ('d 's! 'so 'd)]
          |  "_;_" : 'Substitution 'Substitution
             [assoc prec (71) format('d 's! 'so 'd)]
       'Metadata
         ::= <string>
       'Number
         ::= <number>
     endgr .

  *** commands  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
  op cmd-grammar : CITP -> Grammar .
  eq cmd-grammar(CITP)
   = grammar 'CITP/Cmd/Syntax is
       'Command
         ::= "import_module_" : 'SpecLang 'ModuleName
          |  lit "list modules"
          |  "show module_" : 'ModuleName
          |  lit "list goals"
          |  "show goal_" : 'GoalName
          |  lit "show goals"
          |  lit "list proofs"
          |  "show proof_" : 'ProofName
          |  lit "show proofs"
          |  "begin proof_of_" : 'ProofName 'GoalName [none]
       'ProofCommand
         ::= lit "qed"
          |  lit "show proof"
          |  lit "show goals"
          |  lit "show goals abridged"
          |  lit "show goal"
          |  lit "show goal abridged"
          |  lit "show module"
          |  lit "show additions"
          |  lit "rollback"
          |  "reduce term_" : 'Term
          |  "search path from_to_" : 'Term 'Term [none]
       'SpecLang
         ::= bubble "specLang" [balanced-parentheses exclude("module")]
       'ModuleName
         ::= token "moduleName"
       'GoalName
         ::= token "goalName"
       'ProofName
         ::= token "proofName"
       'Term
         ::= bubble "term" [balanced-parentheses]
     endgr .

  *** multiline comments  - - - - - - - - - - - - - - - - - - - - - - - - - - --
  op cmnt-grammar : CITP -> Grammar .
  eq cmnt-grammar(CITP)
   = grammar 'CITP/cmnt-syntax is
       'Comment
         ::= "***_" : 'Text [none]
       'Text
         ::= bubble "text" [balanced-parentheses]
     endgr .
endfm

*** ----------------------------------------------------------------------------

view CITP from LANGUAGE to CITP/LANGUAGE is
  sort Lid to CITP .
  op Lid to CITP .
  op grammar to goal-grammar .
endv

********************************************************************************

fmod CITP/READ is
  protecting CITP/LANGUAGE .
  protecting CITP/DATABASE .
  protecting CITP/CMD .
  protecting ATERM/READ .
  protecting QID-SET/OPS .

  var  L : CITP .
  var  MD : ModuleDict{CITP} .
  var  GD : GoalDict{CITP} .
  vars LN MN GN H C : ATerm .
  vars FDL1 FDL2 : ATerm .
  vars F F1 F2 LHS RHS S VL VL1 VL2 T T1 T2 : ATerm .
  var  FI : Variable .
  var  V : AVariable .
  vars AL AL1 AL2 Subst Subst1 Subst2 l md mdn n : ATerm .
  vars PN STtL STtL1 STtL2 TtL TtL1 TtL2 : ATerm .

  *** read goal  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  op read-goal : CITP ATerm ModuleDict{CITP} ~> Goal{CITP} .
  eq read-goal(L, {'goal_is`|-`{_`}_endg[GN, MN, C] : 'Goal}, MD)
   = goal read-goal-name(L, GN)[nil] is
       no-fd
     |-{MD[read-module-name(L, MN)][nil]}
       read-formulas(L, C)
     endg .
  eq read-goal(L, {'goal_is_|-`{_`}_endg[GN, H, MN, C] : 'Goal}, MD)
   = goal read-goal-name(L, GN)[nil] is
       read-formulas(L, H)
     |-{MD[read-module-name(L, MN)][nil]}
       read-formulas(L, C)
     endg .

  *** read goal name  - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
  op read-goal-name : CITP ATerm -> QidList .
  eq read-goal-name(L, GN) = read-qids(GN) .

  *** read module name  - - - - - - - - - - - - - - - - - - - - - - - - - - - --
  op read-module-name : CITP ATerm -> QidList .
  eq read-module-name(L, MN) = read-qids(MN) .

  *** read-formulas  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  op read-formulas : CITP ATerm ~> FormDeclList{CITP} .
  eq read-formulas(L, {'__[FDL1, FDL2] : 'FormDeclList})
   = read-formulas(L, FDL1) read-formulas(L, FDL2) .
  eq read-formulas(L, {'fm_.[F] : 'FormDecl})
   = (fm read-formula(L, F) [none] .) .
  eq read-formulas(L, {'fm_`[_`].[F, AL] : 'FormDecl})
   = (fm read-formula(L, F) [read-attributes(L, AL)] .) .
  eq read-formulas(L, T) = no-fd [owise] .

  *** read-formula  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
  op read-formula : CITP ATerm ~> Formula{CITP} .
  eq read-formula(L, {'true.Formula : 'Formula})
   = true .
  eq read-formula(L, {'false.Formula : 'Formula})
   = false .
  eq read-formula(L, {'_=_[LHS, RHS] : 'Formula})
   = plain-term(LHS) =[L]= plain-term(RHS) .
  eq read-formula(L, {'_:_[T, S] : 'Formula})
   = plain-term(T) :[L]: read-qid(S) .
  eq read-formula(L, {'_:=_[LHS, RHS] : 'Formula})
   = plain-term(LHS) :[L]= plain-term(RHS) .
  eq read-formula(L, {'_=>_[LHS, RHS] : 'Formula})
   = plain-term(LHS) =[L]> plain-term(RHS) .
  eq read-formula(L, {'~_[F] : 'Formula})
   = ~ read-formula(L, F) .
  eq read-formula(L, {'_/\_[F1, F2] : 'Formula})
   = read-formula(L, F1) /\ read-formula(L, F2) .
  eq read-formula(L, {'_\/_[F1, F2] : 'Formula})
   = read-formula(L, F1) \/ read-formula(L, F2) .
  eq read-formula(L, {'_if_[F1, F2] : 'Formula})
   = read-formula(L, F1) if read-formula(L, F2) .
  eq read-formula(L, {'forall`{_`}_[VL, F] : 'Formula})
   = forall {set(read-varlist(L, VL))} read-formula(L, F) .
  eq read-formula(L, {'exists`{_`}_[VL, F] : 'Formula})
   = exists {set(read-varlist(L, VL))} read-formula(L, F) .
  eq read-formula(L, {FI : 'Formula})
   = fmvar(L, getName(FI)) .

  *** read variable list  - - - - - - - - - - - - - - - - - - - - - - - - - - --
  op read-varlist : CITP ATerm -> QidList .
  eq read-varlist(L, {'_`,_[VL1, VL2] : 'VarList})
   = read-varlist(L, VL1) read-varlist(L, VL2) .
  eq read-varlist(L, V) = plain-term(V) .
  eq read-varlist(L, T) = nil [owise] .

  *** read attributes  - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  op read-attributes : CITP ATerm ~> AttrSet .
  eq read-attributes(L, {'__[AL1, AL2] : 'AttrList})
   = read-attributes(L, AL1) read-attributes(L, AL2) .
  eq read-attributes(L, {'label_[l] : 'Attr})
   = label(read-qid(l)) .
  eq read-attributes(L, {'metadata_[md] : 'Attr})
   = metadata(read-string(md)) .
  eq read-attributes(L, {'owise.Attr : 'Attr})
   = owise .
  eq read-attributes(L, {'nonexec.Attr : 'Attr})
   = nonexec .
  eq read-attributes(L, T)
   = none [owise] .

  *** read proof name  - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  op read-proof-name : CITP ATerm -> Qid .
  eq read-proof-name(L, PN) = read-qid(PN) .

  *** read tactics  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
  op read-tactic-lists : CITP ATerm -> Seq{TacticList{CITP}} .
  eq read-tactic-lists(L, {'__[STtL1, STtL2] : 'TacticListSeq})
   = read-tactic-lists(L, STtL1) read-tactic-lists(L, STtL2) .
  eq read-tactic-lists(L, {'_.[TtL] : 'TacticListSeq})
   = (read-tactics(L, TtL) .) .

  op read-tactics : CITP ATerm -> TacticList{CITP} .
  eq read-tactics(L, {'__[TtL1, TtL2] : 'TacticList})
   = read-tactics(L, TtL1) read-tactics(L, TtL2) .
  eq read-tactics(L, {'split.Tactic : 'Tactic})
   = Tactic[L]{split} .
  eq read-tactics(L, {'@crt[TtL] : 'Tactic})
   = Tactic[L]{@crt read-tactics(L, TtL)} .
  eq read-tactics(L, {'simp.Tactic : 'Tactic})
   = Tactic[L]{simp} .
  eq read-tactics(L, {'red.Tactic : 'Tactic})
   = Tactic[L]{red} .
  eq read-tactics(L, {'imp.Tactic : 'Tactic})
   = Tactic[L]{imp} .
  eq read-tactics(L, {'conj.Tactic : 'Tactic})
   = Tactic[L]{conj} .
  eq read-tactics(L, {'disj[mdn] : 'Tactic})
   = if mdn :: <string>
     then Tactic[L]{disj read-string(mdn)}
     else Tactic[L]{disj read-num(mdn)} fi .
  eq read-tactics(L, {'tc.Tactic : 'Tactic})
   = Tactic[L]{tc} .
  eq read-tactics(L, {'sk.Tactic : 'Tactic})
   = Tactic[L]{sk} .
  eq read-tactics(L, {'ca.Tactic : 'Tactic})
   = Tactic[L]{ca} .
  eq read-tactics(L, {'ca-rev.Tactic : 'Tactic})
   = Tactic[L]{ca-rev} .
  eq read-tactics(L, {'cs.Tactic : 'Tactic})
   = Tactic[L]{cs} .
  eq read-tactics(L, {'trans.Tactic : 'Tactic})
   = Tactic[L]{trans} .
  eq read-tactics(L, {'ind[VL] : 'Tactic})
   = Tactic[L]{ind read-varlist(L, VL)} .
  eq read-tactics(L, {'ind-schema[VL] : 'Tactic})
   = Tactic[L]{ind-schema read-varlist(L, VL)} .
  eq read-tactics(L, {'init[mdn, Subst] : 'Tactic})
   = if mdn :: <string>
     then Tactic[L]{init read-string(mdn), read-substitution(L, Subst)}
     else Tactic[L]{init read-num(mdn), read-substitution(L, Subst)} fi .
  eq read-tactics(L, {'init[md] : 'Tactic})
   = Tactic[L]{init read-string(md) } .
  eq read-tactics(L, {'init-all.Tactic : 'Tactic})
   = Tactic[L]{init-all} .
  eq read-tactics(L, {'subst[Subst] : 'Tactic})
   = Tactic[L]{subst read-substitution(L, Subst) } .
  eq read-tactics(L, {'pull[md] : 'Tactic})
   = Tactic[L]{pull read-string(md)} .
  eq read-tactics(L, {'push[mdn] : 'Tactic})
   = if mdn :: <string>
     then Tactic[L]{push read-string(mdn)}
     else Tactic[L]{push read-num(mdn)} fi .
  eq read-tactics(L, {'push-all.Tactic : 'Tactic})
   = Tactic[L]{push-all} .
  eq read-tactics(L, {'select[n] : 'Tactic})
   = Tactic[L]{select read-num(n)} .
  eq read-tactics(L, {'pass.Tactic : 'Tactic})
   = Tactic[L]{pass} .
  eq read-tactics(L, TtL) = idle [owise] .

  *** read substitution  - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  op read-substitution : CITP ATerm -> Substitution .
  eq read-substitution(L, {'_;_[Subst1, Subst2] : 'Substitution})
   = read-substitution(L, Subst1) ; read-substitution(L, Subst2) .
  eq read-substitution(L, {'_<-_[V, T] : 'Substitution})
   = plain-term(V) <- plain-term(T) .

  *** read command  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
  op read-cmd : CITP ATerm ~> Cmd{CITP} .
  eq read-cmd(L, {'import_module_[LN, MN] : 'Command})
   = Cmd[L]{import read-lang-name(L, LN) module read-module-name(L, MN)} .
  eq read-cmd(L, {'list`modules.Command : 'Command})
   = Cmd[L]{list modules} .
  eq read-cmd(L, {'show`module_[MN] : 'Command})
   = Cmd[L]{show module read-module-name(L, MN)} .
  eq read-cmd(L, {'list`goals.Command : 'Command})
   = Cmd[L]{list goals} .
  eq read-cmd(L, {'show`goal_[GN] : 'Command})
   = Cmd[L]{show goal read-goal-name(L, GN)} .
  eq read-cmd(L, {'show`goals.Command : 'Command})
   = Cmd[L]{show goals} .
  eq read-cmd(L, {'list`proofs.Command : 'Command})
   = Cmd[L]{list proofs} .
  eq read-cmd(L, {'show`proofs.Command : 'Command})
   = Cmd[L]{show proofs} .
  eq read-cmd(L, {'show`proof_[PN] : 'Command})
   = Cmd[L]{show proof read-proof-name(L, PN)} .
  eq read-cmd(L, {'begin`proof_of_[PN, GN] : 'Command})
   = Cmd[L]{begin proof read-proof-name(L, PN) of read-goal-name(L, GN)} .
  eq read-cmd(L, {'qed.ProofCommand : 'ProofCommand})
   = Cmd[L]{qed} .
  eq read-cmd(L, {'show`proof.ProofCommand : 'ProofCommand})
   = Cmd[L]{show ongoing proof} .
  eq read-cmd(L, {'show`goals.ProofCommand : 'ProofCommand})
   = Cmd[L]{show goals} .
  eq read-cmd(L, {'show`goals`abridged.ProofCommand : 'ProofCommand})
   = Cmd[L]{show goals abridged} .
  eq read-cmd(L, {'show`goal.ProofCommand : 'ProofCommand})
   = Cmd[L]{show current goal} .
  eq read-cmd(L, {'show`goal`abridged.ProofCommand : 'ProofCommand})
   = Cmd[L]{show current goal abridged} .
  eq read-cmd(L, {'show`module.ProofCommand : 'ProofCommand})
   = Cmd[L]{show current module} .
  eq read-cmd(L, {'show`additions.ProofCommand : 'ProofCommand})
   = Cmd[L]{show additions} .
  eq read-cmd(L, {'rollback.ProofCommand : 'ProofCommand})
   = Cmd[L]{rollback} .
  eq read-cmd(L, {'reduce`term_[T] : 'ProofCommand})
   = Cmd[L]{reduce term T} .
  eq read-cmd(L, {'search`path`from_to_[T1, T2] : 'ProofCommand})
   = Cmd[L]{search path from T1 to T2} .

  op read-lang-name : CITP ATerm -> QidList .
  eq read-lang-name(L, LN) = read-qids(LN) .
endfm

********************************************************************************

fmod CITP/MODULE-PRINTING is
  protecting PRINTING/COMPAT .
  protecting CITP/LANGUAGE .
  protecting CITP/BRIDGE/PREAMBLE .

  var  L : CITP .
  vars M M0 : Module .
  var  S : Sort .
  vars ODS MDOS : OpDeclSet .
  vars MS MDMS : MembAxSet .
  vars ES MDES : EquationSet .
  var  R : Rule .
  vars RS MDRS : RuleSet .
  var  QI : Qid .
  var  TPL : TypeList .
  var  TP : Type .
  vars T LHS RHS : Term .
  var  EC : EqCondition .
  vars C C1 C2 : Condition .
  var  AtS : AttrSet .
  var  TR : Trace .
  vars TS1 TS2 : TraceStep .

  *** print module declarations  - - - - - - - - - - - - - - - - - - - - - - - -
  op print : CITP Module -> QidList .
  eq print(L, M)
   = print term upTerm(M) given (upModule('META-MODULE, false) & none) .

  *** attributes  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  --
  op print : CITP AttrSet -> QidList .
  eq print(L, AtS)
   = print term upTerm(AtS) given (upModule('META-MODULE, false) & none) .

  *** operations  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  --
  op print : CITP OpDeclSet -> QidList .
  eq print(L, ODS) = intercalate('\n, print2(L, ODS)) .

  op print2 : CITP OpDeclSet -> QidList2 .
  eq print2(L, (none).OpDeclSet) = nil .
  eq print2(L, op QI : TPL -> TP [AtS] . ODS)
   = :['op '\s QI '\s ': '\s if TPL == nil then nil else TPL '\s fi '-> '\s TP
     if AtS == none then nil else '\s '`[ print(L, AtS) '`] '\s fi '.]
     print2(L, ODS) .

  *** conditions  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  --
  op print : CITP Module Condition -> QidList .
  eq print(L, M, (nil).Condition) = 'true .
  eq print(L, M, T : S)
   = print term T given (M & none) '\s ': '\s S .
  eq print(L, M, LHS = RHS)
   = print term LHS given (M & none)
     '\s '= '\s
     print term RHS given (M & none) .
  eq print(L, M, LHS := RHS)
   = print term LHS given (M & none)
     '\s ':= '\s
     print term RHS given (M & none) .
  eq print(L, M, LHS => RHS)
   = print term LHS given (M & none)
     '\s '=> '\s
     print term RHS given (M & none) .
  ceq print(L, M, C1 /\ C2) = print(L, M, C1) '\s '/\ '\s print(L, M, C2)
   if C1 =/= nil /\ C2 =/= nil .

  *** membership axioms  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -
  op print2 : CITP Module MembAxSet -> QidList2 .
  eq print2(L, M, (none).MembAxSet) = nil .
  eq print2(L, M, mb T : S [AtS] . MS)
   = :['mb '\s print(L, M, T : S) '\s
        if AtS == none then nil else '`[ print(L, AtS) '`] '\s fi '.]
     print2(L, M, MS) .
  eq print2(L, M, cmb T : S if EC [AtS] . MS)
   = :['cmb '\s print(L, M, T : S) '\s 'if '\s print(L, M, EC) '\s
        if AtS == none then nil else '`[ print(L, AtS) '`] '\s fi '.]
     print2(L, M, MS) .

  op print : CITP Module MembAxSet -> QidList .
  eq print(L, M, MS) = intercalate('\n, print2(L, M, MS)) .

  *** equations  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - -
  op print2 : CITP Module EquationSet -> QidList2 .
  eq print2(L, M, (none).EquationSet) = nil .
  eq print2(L, M, eq LHS = RHS [AtS] . ES)
   = :['eq '\s print(L, M, LHS = RHS) '\s
        if AtS == none then nil else '`[ print(L, AtS) '`] '\s fi '.]
     print2(L, M, ES) .
  eq print2(L, M, ceq LHS = RHS if EC [AtS] . ES)
   = :['ceq '\s print(L, M, LHS = RHS) '\s 'if '\s print(L, M, EC) '\s
        if AtS == none then nil else '`[ print(L, AtS) '`] '\s fi '.]
     print2(L, M, ES) .

  op print : CITP Module EquationSet -> QidList .
  eq print(L, M, ES) = intercalate('\n, print2(L, M, ES)) .

  *** rules  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -
  op print2 : CITP Module RuleSet -> QidList2 .
  eq print2(L, M, (none).RuleSet) = nil .
  eq print2(L, M, rl LHS => RHS [AtS] . RS)
   = :['rl '\s print(L, M, LHS => RHS) '\s
        if AtS == none then nil else '`[ print(L, AtS) '`] '\s fi '.]
     print2(L, M, RS) .
  eq print2(L, M, crl LHS => RHS if C [AtS] . RS)
   = :['crl '\s print(L, M, LHS => RHS) '\s 'if '\s print(L, M, C) '\s
        if AtS == none then nil else '`[ print(L, AtS) '`] '\s fi '.]
     print2(L, M, RS) .

  op print : CITP Module RuleSet -> QidList .
  eq print(L, M, RS) = intercalate('\n, print2(L, M, RS)) .

  *** additions  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - -
  op print2-additions : CITP Module Module -> QidList2 .
  ceq print2-additions(L, M, M0)
   = if MDOS == none then nil else print2(L, MDOS) fi
     if MDMS == none then nil else print2(L, M, MDMS) fi
     if MDES == none then nil else print2(L, M, MDES) fi
     if MDRS == none then nil else print2(L, M, MDRS) fi
   if MDOS := getOps(M) \ getOps(M0)
      /\ MDMS := getMbs(M) \ getMbs(M0)
      /\ MDES := getEqs(M) \ getEqs(M0)
      /\ MDRS := getRls(M) \ getRls(M0) .

  op print-additions : CITP Module Module -> QidList .
  eq print-additions(L, M, M0)
   = intercalate('\n, print2-additions(L, M, M0)) .

  *** print trace  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  op print : CITP Module Trace? -> QidList .
  eq print(L, M, (nil).Trace) = (nil).QidList .
  eq print(L, M, {T,TP,R})
   = '`{ print term T given (M & none) '`, '\y TP '\o '`, '\n '
      print(L, M, R) '`} .
  eq print(L, M, TS1 TS2 TR)
   = print(L, M, TS1) '\n print(L, M, TS2 TR).
  eq print(L, M, failure) = 'failure .

  *** print trace  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  op print : CITP Module Trace? -> QidList .
  eq print(L, M, (nil).Trace) = (nil).QidList .
  eq print(L, M, {T,TP,R})
   = '`{ print term T given (M & none) '`, '\y TP '\o '`, '\n '
      print(L, M, R) '`} .
  eq print(L, M, TS1 TS2 TR)
   = print(L, M, TS1) '\n print(L, M, TS2 TR).
  eq print(L, M, failure) = 'failure .
endfm

********************************************************************************

fmod CITP/SHOW is
  protecting CITP/MODULE-PRINTING .
  protecting PRINTING/GRAMMAR-BASED .
  protecting CITP/MODULE-DICT .
  protecting CITP/APPLY/ALL .
  protecting TERM/ASSIGNMENT-LIST .
  protecting STRING/SHOW .
  protecting NUM/SHOW .

  var  L : CITP .
  vars M M0 : Module .
  var  G : Goal{CITP} .
  var  GL : GoalList{CITP} .
  var  NGL : NeGoalList{CITP} .
  vars H C : FormDeclList{CITP} .
  vars NFDL1 NFDL2 : NeFormDeclList{CITP} .
  vars F F1 F2 : Formula{CITP} .
  var  Tt : Tactic{CITP} .
  var  TtL : TacticList{CITP} .
  var  NTtL : NeTacticList{CITP} .
  var  STtL : Seq{TacticList{CITP}} .
  var  NSTtL1 NSTtL2 : NeSeq{TacticList{CITP}} .
  vars GN MN PN l V FI : Qid .
  vars QIL GA MA : QidList .
  var  QLL : QidList2 .
  var  md : String .
  vars LHS RHS T : Term .
  var  S : Sort .
  var  NVS : NeVariableSet .
  var  NVL : NeQidList .
  var  Subst : Substitution .
  var  AL : AssignmentList .
  var  n : Nat .
  var  AtS : AttrSet .

  *** show goal  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  op show-goal : CITP Goal{CITP} -> Term .
  eq show-goal(L, goal GN[GA] is no-fd |-{M[MA]} C endg)
   = 'goal_is`|-`{_`}_endg [
       show-goal-name(L, GN, GA),
       show-module-name(L, getName(M), MA),
       pack('__, show-formulas(L, M, C)) ] .
  eq show-goal(L, goal GN[GA] is H |-{M[MA]} C endg)
   = 'goal_is_|-`{_`}_endg [
       show-goal-name(L, GN, GA),
       pack('__, show-formulas(L, M, H)),
       show-module-name(L, getName(M), MA),
       pack('__, show-formulas(L, M, C)) ] [owise] .

  op show-goal : CITP Goal{CITP} Module -> Term .
  eq show-goal(L, goal GN[GA] is no-fd |-{M[MA]} C endg, M0)
   = if M == M0
     then show-goal(L, goal GN[GA] is no-fd |-{M[MA]} C endg)
    else 'goal_is`|-`{_`}_endg [
        show-goal-name(L, GN, GA),
        show-module(L, M, MA, M0),
        pack('__, show-formulas(L, M, C)) ] fi .
  eq show-goal(L, goal GN[GA] is H |-{M[MA]} C endg, M0)
   = if M == M0
     then show-goal(L, goal GN[GA] is H |-{M[MA]} C endg)
     else 'goal_is_|-`{_`}_endg [
        show-goal-name(L, GN, GA),
        pack('__, show-formulas(L, M, H)),
        show-module(L, M, MA, M0),
        pack('__, show-formulas(L, M, C)) ] fi [owise] .

  *** show module  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  op show-module : CITP Module QidList Module -> Term  .
  eq show-module(L, M, MA, M0)
   = 'th_is`protecting_._endth [
       show-module-name(L, getName(M), MA),
       show-module-name(L, getName(M), nil),
       pack('__, show-module-additions(L, print2-additions(L, M, M0))) ] .

  *** show goal name  - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
  op show-goal-name : CITP Qid QidList -> Term .
  eq show-goal-name(L, GN, nil)
   = mk-bubble('goalName, show-qids(mksord(GN))) .
  eq show-goal-name(L, GN, GA)
   = mk-bubble('goalName,
      show-qids(mksord(qid(GN '`[ intersperse('`] '`[, GA) '`])))) [owise] .

  *** show module name  - - - - - - - - - - - - - - - - - - - - - - - - - - - --
  op show-module-name : CITP Qid QidList -> Term .
  eq show-module-name(L, MN, MA)
   = mk-bubble('moduleName, show-qids(mksord(qid(MN MA)))) .

  *** show module additions  - - - - - - - - - - - - - - - - - - - - - - - - - -
  op show-module-additions : CITP QidList2 -> TermList .
  eq show-module-additions(L, nil) = empty .
  eq show-module-additions(L, :[QIL] QLL)
   = mk-bubble('maude-declaration, show-qids(QIL)),
     show-module-additions(L, QLL) .

  *** show formulas  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  op show-formulas : CITP Module FormDeclList{CITP} -> TermList .
  eq show-formulas(L, M, no-fd) = empty .
  eq show-formulas(L, M, NFDL1 NFDL2)
   = show-formulas(L, M, NFDL1), show-formulas(L, M, NFDL2) .
  eq show-formulas(L, M, fm F [none] .)
   = 'fm_. [bubble-formula(L, M, F)] .
  eq show-formulas(L, M, fm F [AtS] .)
   = 'fm_`[_`]. [bubble-formula(L, M, F), show-attributes(L, AtS)] .

  op bubble-formula : CITP Module Formula{CITP} -> Term .
  eq bubble-formula(L, M, F)
   = mk-bubble('formula,
      show-qids(print term show-formula(L, M, F) given fm-grammar(L))) .

  *** show formula  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
  op show-formula : CITP Module Formula{CITP} -> Term .
  eq show-formula(L, M, true) = 'true.Formula .
  eq show-formula(L, M, false) = 'false.Formula .
  eq show-formula(L, M, LHS =[L]= RHS)
   = '_=_ [
      mk-bubble('term, show-qids(print term (LHS) given (M & none))),
      mk-bubble('term, show-qids(print term (RHS) given (M & none))) ] .
  eq show-formula(L, M, T :[L]: S)
   = '_:_ [
      mk-bubble('term, show-qids(print term (T) given (M & none))),
      mk-bubble('sort, show-qid(S)) ] .
  eq show-formula(L, M, LHS :[L]= RHS)
   = '_:=_ [
      mk-bubble('term, show-qids(print term (LHS) given (M & none))),
      mk-bubble('term, show-qids(print term (RHS) given (M & none))) ] .
  eq show-formula(L, M, LHS =[L]> RHS)
   = '_=>_ [
      mk-bubble('term, show-qids(print term (LHS) given (M & none))),
      mk-bubble('term, show-qids(print term (RHS) given (M & none))) ] .
  eq show-formula(L, M, ~ F)
   = '~_ [show-formula(L, M, F)] .
  eq show-formula(L, M, F1 /\ F2)
   = '_/\_ [show-formula(L, M, F1), show-formula(L, M, F2)] .
  eq show-formula(L, M, F1 \/ F2)
   = '_\/_ [show-formula(L, M, F1), show-formula(L, M, F2)] .
  eq show-formula(L, M, F1 if F2)
   = '_if_ [show-formula(L, M, F1), show-formula(L, M, F2)] .
  eq show-formula(L, M, forall {none} F)
   = show-formula(L, M, F) .
  eq show-formula(L, M, forall {NVS} F)
   = 'forall`{_`}_ [show-varlist(L, list(NVS)), show-formula(L, M, F) ] .
  eq show-formula(L, M, exists {none} F)
   = show-formula(L, M, F) .
  eq show-formula(L, M, exists {NVS} F)
   = 'exists`{_`}_ [show-varlist(L, list(NVS)), show-formula(L, M, F) ] .
  eq show-formula(L, M, fmvar(L, FI))
   = var(FI, 'Formula) .

  *** show variable list  - - - - - - - - - - - - - - - - - - - - - - - - - - --
  op show-varlist : CITP NeQidList -> NeTermList .
  eq show-varlist(L, V)
   = mk-bubble('variable, show-qid(V)) .
  eq show-varlist(L, V NVL)
   = '_`,_ [show-varlist(L, V), show-varlist(L, NVL)] .

  *** show attributes  - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  op show-attributes : CITP AttrSet -> Term .
  eq show-attributes(L, AtS)
   = mk-bubble('attrList,
      show-qids(
        print term pack('__,
          (show-label-attr(L, AtS),
           show-metadata-attr(L, AtS),
           show-nonexec-attr(L, AtS),
           show-owise-attr(L, AtS)))
        given fm-attr-grammar(L))) .

  op show-label-attr : CITP AttrSet -> TermList .
  ceq show-label-attr(L, label(l) AtS)
   = 'label_ [mk-bubble('label, show-qid(l))] if AtS is label-free .
  eq show-label-attr(L, AtS) = empty [owise] .

  op show-metadata-attr : CITP AttrSet -> TermList .
  ceq show-metadata-attr(L, metadata(md) AtS)
   = 'metadata_ [show-string(md)] if AtS is metadata-free .
  eq show-metadata-attr(L, AtS) = empty [owise] .

  op show-nonexec-attr : CITP AttrSet -> TermList .
  eq show-nonexec-attr(L, nonexec AtS) = 'nonexec.Attr .
  eq show-nonexec-attr(L, AtS) = empty [owise] .

  op show-owise-attr : CITP AttrSet -> TermList .
  eq show-owise-attr(L, owise AtS) = 'owise.Attr .
  eq show-owise-attr(L, AtS) = empty [owise] .

  *** show proof  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
  op show-proof : CITP Proof{CITP} -> Term .
  eq show-proof(L, proof PN of G is no-tl qed)
   = 'proof_of_is`qed [
       show-proof-name(L, PN),
       show-goal-name(L, name(G), nil) ] .
  eq show-proof(L, proof PN of G is STtL qed)
   = 'proof_of_is_qed [
       show-proof-name(L, PN),
       show-goal-name(L, name(G), nil),
       pack('__, show-tactic-lists(L, G, STtL)) ] [owise] .

  *** show proof name  - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  op show-proof-name : CITP Qid -> Term .
  eq show-proof-name(L, PN)
   = mk-bubble('proofName, show-qid(PN)) .

  *** show tactic lists  - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  op show-tactic-lists : CITP GoalList{CITP} Seq{TacticList{CITP}} -> TermList .
  eq show-tactic-lists(L, no-goal, STtL) = empty .
  eq show-tactic-lists(L, NGL, no-tl) = empty .
  eq show-tactic-lists(L, NGL, NSTtL1 NSTtL2)
   = show-tactic-lists(L, NGL, NSTtL1),
     show-tactic-lists(L, apply(NSTtL1, NGL), NSTtL2) .
  eq show-tactic-lists(L, NGL, TtL .)
   = mk-bubble('tacticList,
      show-qids(print term pack('__, show-tactics(L, NGL, TtL))
        given tactic-grammar(L))) .

  *** show tactics  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
  op show-tactics : CITP GoalList{CITP} TacticList{CITP} -> TermList .
  eq show-tactics(L, no-goal, TtL) = empty .
  eq show-tactics(L, NGL, Tt NTtL)
   = show-tactics(L, NGL, Tt), show-tactics(L, apply(Tt, NGL), NTtL) .
  eq show-tactics(L, NGL, Tactic[L]{reduce})
   = 'reduce.Tactic .
  eq show-tactics(L, NGL, Tactic[L]{split})
   = 'split.Tactic .
  eq show-tactics(L, NGL, Tactic[L]{@crt NTtL})
   = '@crt[pack('__, show-tactics(L, head-goal(NGL), NTtL))] .
  eq show-tactics(L, NGL, Tactic[L]{simp})
   = 'simp.Tactic .
  eq show-tactics(L, NGL, Tactic[L]{red})
   = 'red.Tactic .
  eq show-tactics(L, NGL, Tactic[L]{imp})
   = 'imp.Tactic .
  eq show-tactics(L, NGL, Tactic[L]{conj})
   = 'conj.Tactic .
  eq show-tactics(L, NGL, Tactic[L]{disj n})
   = 'disj[show-num(n)] .
  eq show-tactics(L, NGL, Tactic[L]{disj md})
   = 'disj[show-string(md)] .
  eq show-tactics(L, NGL, Tactic[L]{tc})
   = 'tc.Tactic .
  eq show-tactics(L, NGL, Tactic[L]{sk})
   = 'sk.Tactic .
  eq show-tactics(L, NGL, Tactic[L]{ca})
   = 'ca.Tactic .
  eq show-tactics(L, NGL, Tactic[L]{ca-rev})
   = 'ca-rev.Tactic .
  eq show-tactics(L, NGL, Tactic[L]{cs})
   = 'cs.Tactic .
  eq show-tactics(L, NGL, Tactic[L]{trans})
   = 'trans.Tactic .
  eq show-tactics(L, NGL, Tactic[L]{ind NVL})
   = 'ind[show-varlist(L, NVL)] .
  eq show-tactics(L, NGL, Tactic[L]{ind-schema NVL})
   = 'ind-schema[show-varlist(L, NVL)] .
  eq show-tactics(L, NGL, Tactic[L]{init md, Subst})
   = 'init[show-string(md), show-substitution(L, current-module(NGL), Subst)] .
  eq show-tactics(L, NGL, Tactic[L]{init n, Subst})
   = 'init[show-num(n), show-substitution(L, current-module(NGL), Subst)] .
  eq show-tactics(L, NGL, Tactic[L]{init md})
   = 'init[show-string(md)] .
  eq show-tactics(L, NGL, Tactic[L]{init-all})
   = 'init-all.Tactic .
  eq show-tactics(L, NGL, Tactic[L]{subst Subst})
   = 'subst[ show-substitution(L, current-module(NGL), Subst) ] .
  eq show-tactics(L, NGL, Tactic[L]{pull md})
   = 'pull[show-string(md)] .
  eq show-tactics(L, NGL, Tactic[L]{push md})
   = 'push[show-string(md)] .
  eq show-tactics(L, NGL, Tactic[L]{push n})
   = 'push[show-num(n)] .
  eq show-tactics(L, NGL, Tactic[L]{push-all})
   = 'push-all.Tactic .
  eq show-tactics(L, NGL, Tactic[L]{select n})
   = 'select[show-num(n)] .
  eq show-tactics(L, NGL, Tactic[L]{pass})
   = 'pass.Tactic .
  eq show-tactics(L, NGL, TtL) = empty [owise] .

  *** show substitution  - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  op show-substitution : CITP Module Substitution -> Term .
  eq show-substitution(L, M, Subst)
   = pack('_;_, show-assignments(L, M, list(Subst))) .

  op show-assignments : CITP Module AssignmentList -> TermList .
  eq show-assignments(L, M, nil) = empty .
  eq show-assignments(L, M, {V <- T} AL)
   = '_<-_ [
       mk-bubble('variable, show-qid(V)),
       mk-bubble('term, show-qids(print term (T) given (M & none)))
     ], show-assignments(L, M, AL) .
endfm

********************************************************************************

fmod CITP/ANALYSIS-STATE is
  protecting CITP/READ .
  protecting CITP/SPEC-LANG/BASE .
  protecting CITP/APPLY/ALL .

  var L : CITP .
  var SAS : AnalysisState{CITP} .
  var DB : SpeX/DB .
  var SL : QidList .
  var MD : ModuleDict{CITP} .
  var GD : GoalDict{CITP} .
  var GL : GoalList{CITP} .
  var PD : ProofDict{CITP} .
  var M : Module .
  var T : ATerm .

  *** analysis state  - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
  sort AnalysisState{CITP} .
  op AnalysisState[_]{_/_&_&_} : CITP SpeX/DB ModuleDict{CITP} GoalDict{CITP}
    ProofDict{CITP} -> AnalysisState{CITP} [ctor] .
  op AnalysisState[_]{_/_} : CITP SpeX/DB QidList
    -> AnalysisState{CITP} [ctor] .
  op AnalysisState[_]{_&_} : CITP ModuleDict{CITP} GoalDict{CITP}
    -> AnalysisState{CITP} [ctor] .
  op AnalysisState[_]{_} : CITP ModuleDict{CITP} -> AnalysisState{CITP} [ctor] .
  op AnalysisState[_]{_} : CITP GoalDict{CITP} -> AnalysisState{CITP} [ctor] .
  op AnalysisState[_]{_} : CITP GoalList{CITP} -> AnalysisState{CITP} [ctor] .
  op AnalysisState[_]{_} : CITP Module -> AnalysisState{CITP} [ctor] .

  *** SpeX database  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  op db : AnalysisState{CITP} -> SpeX/DB .
  eq db(AnalysisState[L]{DB / MD & GD & PD}) = DB .
  eq db(AnalysisState[L]{DB / SL}) = DB .
  eq db(SAS) = empty [owise] .

  *** specification language  - - - - - - - - - - - - - - - - - - - - - - - - --
  op lang-name : AnalysisState{CITP} -> QidList .
  eq lang-name(AnalysisState[L]{DB / SL}) = SL .
  eq lang-name(SAS) = nil [owise] .

  *** modules  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  op modules : AnalysisState{CITP} -> ModuleDict{CITP} .
  eq modules(AnalysisState[L]{DB / MD & GD & PD}) = MD .
  eq modules(AnalysisState[L]{MD & GD}) = MD .
  eq modules(AnalysisState[L]{MD}) = MD .
  eq modules(SAS) = empty [owise] .

  op module-names : AnalysisState{CITP} -> QidSet .
  eq module-names(SAS) = module-names(modules(SAS)) .

  op current-module : AnalysisState{CITP} -> Module .
  eq current-module(AnalysisState[L]{GL}) = current-module(GL) .
  eq current-module(AnalysisState[L]{M}) = M .
  eq current-module(SAS) = current-module(no-goal) [owise] .

  *** goals  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  op goals : AnalysisState{CITP} -> GoalDict{CITP} .
  eq goals(AnalysisState[L]{DB / MD & GD & PD}) = GD .
  eq goals(AnalysisState[L]{MD & GD}) = GD .
  eq goals(AnalysisState[L]{GD}) = GD .
  eq goals(SAS) = empty [owise] .

  op goal-names : AnalysisState{CITP} -> QidSet .
  eq goal-names(SAS) = goal-names(goals(SAS)) .

  op goal-list : AnalysisState{CITP} -> GoalList{CITP} .
  eq goal-list(AnalysisState[L]{GL}) = GL .
  eq goal-list(SAS) = no-goal [owise] .

  *** proofs  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
  op proofs : AnalysisState{CITP} -> ProofDict{CITP} .
  eq proofs(AnalysisState[L]{DB / MD & GD & PD}) = PD .
  eq proofs(SAS) = empty [owise] .

  *** state updates  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  op _>>=_ : AnalysisState{CITP} ATerm -> AnalysisState{CITP} .
  ceq AnalysisState[L]{GL} >>= T
   = AnalysisState[L]{apply(read-tactic-lists(L, T), GL)}
   if T :: 'TacticListSeq .
  ceq AnalysisState[L]{DB / MD & GD & PD} >>= T
   = AnalysisState[L]{DB / read-lang-name(L, T)}
   if T :: 'SpecLang .
  eq SAS >>= T = SAS [owise] .
endfm

*** ----------------------------------------------------------------------------

view CITP/AnalysisState from ANALYSIS-STATE to CITP/ANALYSIS-STATE is
  sort State to AnalysisState{CITP} .
endv

*** ----------------------------------------------------------------------------

fmod CITP/PARSING is
  including  SYNTACTIC-ANALYSIS { CITP, CITP/AnalysisState } .
  including  PARSING/COMPAT .
  protecting LANG-NAME { CITP } .

  var  L : CITP .
  var  SAS : AnalysisState{CITP} .
  var  GL : GoalList{CITP} .
  vars QIL SL : QidList .
  var  M : Module .
  var  Cmd : Constant .
  vars FI TI SI : Variable .
  vars $LN LN $GN GN $PN PN : ATerm .
  vars STtL STtL1 STtL2 TtL TtL1 TtL2 : ATerm .
  vars $MN MN H C FDL1 FDL2 $F F F1 F2 VL VL1 VL2 $V V : ATerm .
  vars Subst Subst1 Subst2 : ATerm .
  vars $AL AL AL1 AL2 $l l md mdn n : ATerm .
  vars $LHS LHS $RHS RHS $T $T1 $T2 T T1 T2 $S S : ATerm .
  vars N : ATerm .
  vars CT A : Constant .
  vars $ QI AT : Qid .

  *** parse input  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  eq parse L input (QIL) in SAS
   = parse L goal (QIL) in SAS .

  op parse_goal_in_ : CITP QidList AnalysisState{CITP}
    ~> ParsingOutcome .
  eq parse L goal (QIL) in SAS
   = scan L input (QIL : 'Goal)
     then analyse L goal in AnalysisState[L]{modules(SAS)} .

  op parse_tactic`list_in_ : CITP Qid AnalysisState{CITP} ~> ParsingOutcome .
  eq parse L tactic list (QIL) in SAS
   = scan input (QIL : 'TacticList) given tactic-grammar(L)
     then analyse L tactics in SAS .

  op parse_command_in_ : CITP QidList AnalysisState{CITP} ~> ParsingOutcome .
  eq parse L command (QIL) in SAS
   = scan input (QIL : 'Command) given cmd-grammar(L)
     then analyse L command in SAS .

  op parse_proof-cmd_in_ : CITP QidList AnalysisState{CITP} ~> ParsingOutcome .
  eq parse L proof-cmd (QIL) in SAS
   = scan input (QIL : 'ProofCommand) given cmd-grammar(L)
     then analyse L command in SAS .

  op parse_multiline`comment_ : CITP QidList ~> ParsingOutcome .
  eq parse L multiline comment (QIL)
   = scan input (QIL : 'Comment) given cmnt-grammar(L) .

  *** analyse goal  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
  op analyse_goal : CITP -> AnalysisAction{CITP} .

  eq analyse L goal {'goal_is`|-`{_`}_endg[$GN, $MN, C] : 'Goal}
   = try { 'goal_is`|-`{_`}_endg [
        solve L goal name ($GN),
        check L module name ($MN),
        return (C)
      ] : 'PreGoal }
     then analyse L goal .

  ceq analyse L goal {'goal_is`|-`{_`}_endg[GN, MN, C] : 'PreGoal} in SAS
   = try { 'goal_is`|-`{_`}_endg [
        (return (GN), return (MN),
         analyse L formula declarations (C))
         in AnalysisState[L]{modules(SAS)[QI]}
      ] : 'Goal }
   if QI := read-module-name(L, MN) .

  eq analyse L goal {'goal_is_|-`{_`}_endg[$GN, H, $MN, C] : 'Goal}
   = try { 'goal_is_|-`{_`}_endg [
        solve L goal name ($GN),
        return (H),
        check L module name ($MN),
        return (C)
      ] : 'PreGoal }
     then analyse L goal .

  ceq analyse L goal {'goal_is_|-`{_`}_endg[GN, H, MN, C] : 'PreGoal} in SAS
   = try { 'goal_is_|-`{_`}_endg [
        (return (GN),
         analyse L formula declarations (H),
         return (MN),
         analyse L formula declarations (C))
         in AnalysisState[L]{modules(SAS)[QI]}
      ] : 'Goal }
   if QI := read-module-name(L, MN) .

  *** solve goal name  - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  op solve_goal`name : CITP -> AnalysisAction{CITP} .
  ceq solve L goal name {$[GN] : 'GoalName}
   = (check (QIL :: Qid) or-else fail('syntax 'error:
        spaced-emph(QIL) 'is 'not 'a 'valid 'goal 'name))
     and-then return {GN : 'GoalName}
   if QIL := read-goal-name(L, GN) .

  *** analyse goal name  - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  op analyse_goal`name : CITP -> AnalysisAction{CITP} .
  ceq analyse L goal name {$[GN] : 'GoalName} in SAS
   = (check (QIL :: Qid) or-else fail('syntax 'error:
        spaced-emph(QIL) 'is 'not 'a 'valid 'goal 'name))
     and-then
     (check defined(goals(SAS)[QIL]) and-then return {GN : 'GoalName}
      or-else fail ('no 'such 'goal: spaced-emph(QIL))) in SAS
   if QIL := read-goal-name(L, GN) .

  *** check module name  - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  op check_module`name : CITP -> AnalysisAction{CITP} .
  ceq check L module name {$[MN] : 'ModuleName} in SAS
   = (check (QIL :: Qid) or-else fail('syntax 'error:
        spaced-emph(QIL) 'is 'not 'a 'valid 'module 'name))
     and-then
     (check (upModule(QIL, false) :: Module
             or-else QIL in module-names(SAS)
             or-else (QIL :: Variable and-then getType(QIL) == 'Module))
      and-then return {MN : 'ModuleName}
      or-else fail('syntax 'error: 'unknown 'module emph(QIL),
       (at L term ($[MN]), include context))) in SAS
   if QIL := read-module-name(L, MN) .

  *** analyse formula declarations  - - - - - - - - - - - - - - - - - - - - - --
  op analyse_formula`declarations : CITP -> AnalysisAction{CITP} .

  eq analyse L formula declarations {'__[FDL1, FDL2] : 'FormDeclList}
   = try { '__ [
        analyse L formula declarations (FDL1),
        analyse L formula declarations (FDL2)
      ] : 'FormDeclList } .

  eq analyse L formula declarations {'fm_.[$F] : 'FormDecl}
   = try { 'fm_. [
        analyse L formula ($F)
      ] : 'FormDecl } .

  eq analyse L formula declarations {'fm_`[_`].[$F, $AL] : 'FormDecl}
   = try { 'fm_`[_`]. [
        analyse L formula ($F),
        solve L attributes ($AL)
      ] : 'FormDecl } .

  *** analyse formula  - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  op analyse_formula : CITP -> AnalysisAction{CITP} .

  eq analyse L formula {'true.Formula : 'Formula}
   = return {'true.Formula : 'Formula} .

  eq analyse L formula {'false.Formula : 'Formula}
   = return {'false.Formula : 'Formula} .

  eq analyse L formula {'formula[F] : 'Form}
   = decode input (read-qids(F) : 'Formula) given fm-grammar(L)
     then analyse L formula .

  eq analyse L formula {'_=_[$LHS, $RHS] : 'Formula}
   = try { '_=_ [
        analyse L term ($LHS),
        analyse L term ($RHS)
      ] : 'Formula }
     then check that both L terms have the same kind .

  eq analyse L formula {'_:_[$T, $S] : 'Formula}
   = try { '_:_ [
        analyse L term ($T),
        analyse L sort ($S)
      ] : 'Formula } .

  eq analyse L formula {'_:=_[$LHS, $RHS] : 'Formula}
   = try { '_:=_ [
        analyse L term ($LHS),
        analyse L term ($RHS)
      ] : 'Formula }
     then check that both L terms have the same kind .

  eq analyse L formula {'_=>_[$LHS, $RHS] : 'Formula}
   = try { '_=>_ [
        analyse L term ($LHS),
        analyse L term ($RHS)
      ] : 'Formula }
     then check that both L terms have the same kind .

  eq analyse L formula {'~_[F] : 'Formula}
   = try { '~_ [
        analyse L formula (F)
      ] : 'Formula } .

  eq analyse L formula {'_/\_[F1, F2] : 'Formula}
   = try { '_/\_ [
        analyse L formula (F1),
        analyse L formula (F2)
      ] : 'Formula } .

  eq analyse L formula {'_\/_[F1, F2] : 'Formula}
   = try { '_\/_ [
        analyse L formula (F1),
        analyse L formula (F2)
      ] : 'Formula } .

  eq analyse L formula {'_if_[F1, F2] : 'Formula}
   = try { '_if_ [
        analyse L formula (F1),
        analyse L formula (F2)
      ] : 'Formula } .

  eq analyse L formula {'forall`{_`}_[VL, F] : 'Formula}
   = try { 'forall`{_`}_ [
        analyse L varlist (VL),
        analyse L formula (F)
      ] : 'Formula } .

  eq analyse L formula {'exists`{_`}_[VL, F] : 'Formula}
   = try { 'exists`{_`}_ [
        analyse L varlist (VL),
        analyse L formula (F)
      ] : 'Formula } .

  eq analyse L formula {FI : 'Formula}
   = return {FI : 'Formula} .

  *** analyse term  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
  op analyse_term : CITP -> AnalysisAction{CITP} .
  eq analyse L term (T) in AnalysisState[L]{GL}
   = analyse L term (T) in AnalysisState[L]{current-module(GL)} .
  eq analyse L term {$[T] : 'Term} in AnalysisState[L]{M}
   = decode input (read-qids(T) : anyType) given (M & none) .
  eq analyse L term {TI : 'Term} in AnalysisState[L]{M}
   = return {TI : 'Term} in AnalysisState[L]{M} .

  op check`that`both_terms`have`the`same`kind : CITP -> AnalysisAction{CITP} .
  eq check that both L terms have the same kind (T) in AnalysisState[L]{GL}
   = check that both L terms have the same kind (T)
     in AnalysisState[L]{current-module(GL)} .

  ceq check that both L terms have the same kind {AT[LHS, RHS] : 'Formula}
     in AnalysisState[L]{M}
   = check sameKind(M, annotation(LHS), annotation(RHS))
     and-then return {AT[LHS, RHS] : 'Formula}
     or-else fail ('syntax 'error: 'the 'terms
       spaced-emph(print term (LHS) given (M & none)) 'and
       spaced-emph(print term (RHS) given (M & none))
       'do 'not 'have 'the 'same 'kind,
       (at term (RHS) given (M & none), include context))
     in AnalysisState[L]{M}
    if AT in ('_=_ ; '_:=_ ; '_=>_) .

  eq check that both L terms have the same kind {'_<-_[V, T] : 'Substitution}
     in AnalysisState[L]{M}
   = check sameKind(M, annotation(V), annotation(T))
     and-then return {'_<-_[V, T] : 'Substitution}
     or-else fail ('syntax 'error: 'the 'term
       spaced-emph(print term (T) given (M & none)) 'and 'the 'variable
       spaced-emph(print term (V) given (M & none))
       'do 'not 'have 'the 'same 'kind,
       (at term (T) given (M & none), include context))
     in AnalysisState[L]{M} .

  *** analyse sort  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
  op analyse_sort : CITP -> AnalysisAction{CITP} .

  eq analyse L sort {$[S] : 'Sort} in SAS
   = check (read-qid(S) in getSorts(current-module(SAS)))
     and-then return {S : 'Sort}
     or-else fail ('syntax 'error: 'undeclared 'sort
      spaced-emph(print term {$[S] : 'Sort} given fm-grammar(L)),
      (at term {$[S] : 'Sort} given fm-grammar(L), include context))
     in SAS .
  eq analyse L sort {SI : 'Sort}
   = return {SI : 'Sort} .

  *** analyse variable list  - - - - - - - - - - - - - - - - - - - - - - - - - -
  op analyse_varlist : CITP -> AnalysisAction{CITP} .

  eq analyse L varlist {'_`,_[VL1, VL2] : 'VarList}
   = try { '_`,_ [
        analyse L varlist (VL1),
        analyse L varlist (VL2)
      ] : 'VarList } .

  eq analyse L varlist {V : 'Variable}
   = analyse L variable {V : 'Variable} .

  op analyse_variable : CITP -> AnalysisAction{CITP} .
  eq analyse L variable (V) in AnalysisState[L]{GL}
   = analyse L variable (V) in AnalysisState[L]{current-module(GL)} .
  eq analyse L variable {$[V] : 'Variable} in AnalysisState[L]{M}
   = decode input (read-qid(V) : anyType) given (M & none)
     then check L variable in AnalysisState[L]{M} .

  op check_variable : CITP -> AnalysisAction{CITP} .
  ceq check L variable (V) in SAS
   = check V :: AVariable
     and-then return (V)
     or-else fail(emph(print term V given (M & none))
      'is 'not 'a 'variable,
      (at term V given (M & none), include context))
     in SAS
   if M := current-module(SAS) .

  *** solve attributes  - - - - - - - - - - - - - - - - - - - - - - - - - - - --
  op solve_attributes : CITP -> AnalysisAction{CITP} .

  eq solve L attributes ({$[AL] : 'AttrList})
   = decode input (read-qids(AL) : 'AttrList) given fm-attr-grammar(L)
     then solve L attribute list .

  op solve_attribute list : CITP -> AnalysisAction{CITP} .
  eq solve L attribute list {'__[AL1, AL2] : 'AttrList}
   = try { '__ [
        solve L attribute list (AL1),
        solve L attribute list (AL2)
      ] : 'AttrList } .
  eq solve L attribute list {A : 'Attr}
   = return {A : 'Attr} .
  eq solve L attribute list {'label_[$l] : 'Attr}
   = try { 'label_[ solve L label ($l) ] : 'Attr} .
  eq solve L attribute list {'metadata_[md] : 'Attr}
   = return {'metadata_[md] : 'Attr} .

  op solve_label : CITP -> AnalysisAction{CITP} .
  eq solve L label {$[l] : 'Label}
   = check (read-qid(l) :: Qid) and-then return {l : 'Label}
     or-else
     fail ('syntax 'error:
      spaced-emph(print term ($[l]) given fm-attr-grammar(L))
      'is 'not 'a 'valid 'label,
      (at term (l) given fm-attr-grammar(L), include context)) .

  *** solve proof name  - - - - - - - - - - - - - - - - - - - - - - - - - - - --
  op solve_proof`name : CITP -> AnalysisAction{CITP} .
  eq solve L proof name {$[PN] : 'ProofName}
   = return {PN : 'ProofName} .

  *** analyse proof name  - - - - - - - - - - - - - - - - - - - - - - - - - - --
  op analyse_proof`name : CITP -> AnalysisAction{CITP} .
  eq analyse L proof name {$[PN] : 'ProofName} in SAS
   = check defined(proofs(SAS)[read-proof-name(L, PN)])
     and-then return {PN : 'ProofName}
     or-else fail ('no 'such 'proof: emph(read-proof-name(L, PN))) in SAS .

  *** check that goal is defined  - - - - - - - - - - - - - - - - - - - - - - --
  op check`that_goal`is`defined : CITP -> AnalysisAction{CITP} .
  ceq check that L goal is defined {GN : 'GoalName} in SAS
   = check (QI in goal-names(SAS)) and-then return {GN : 'GoalName}
     or-else fail ('syntax 'error: 'unknown 'goal emph(QI),
      (at L term (GN), include context)) in SAS
   if QI := read-goal-name(L, GN) .

  *** analyse tactic lists  - -  - -  - -  - -  - -  - -  - -  - -  - -  - -  --
  op analyse_tactic`lists : CITP -> AnalysisAction{CITP} .

  eq analyse L tactic lists {'__[STtL1, STtL2] : 'TacticListSeq}
   = try { '__ [
        analyse L tactic lists (STtL1),
        analyse L tactic lists (STtL2)
      ] : 'TacticListSeq } .

  eq analyse L tactic lists {'_.[TtL] : 'TacticListSeq}
   = try { '_. [
        analyse L tactics (TtL)
      ] : 'TacticListSeq } .

  *** analyse tactics  - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  op analyse_tactics : CITP -> AnalysisAction{CITP} .

  eq analyse L tactics {'tacticList[TtL] : 'TacticList}
   = decode input (read-qids(TtL) : 'TacticList) given tactic-grammar(L)
     then analyse L tactics .

  eq analyse L tactics {'__[TtL1, TtL2] : 'TacticList}
   = try { '__ [
        analyse L tactics (TtL1),
        analyse L tactics (TtL2)
      ] : 'TacticList } .

  eq analyse L tactics {CT : 'Tactic} in SAS
   = (check (goal-list(SAS) =/= no-goal)
      or-else fail ('nothing 'to 'prove))
     and-then analyse L tactic {CT : 'Tactic} in SAS .

  eq analyse L tactics {T : 'Tactic} in SAS
   = (check (goal-list(SAS) =/= no-goal)
      or-else fail ('nothing 'to 'prove))
     and-then analyse L tactic {T : 'Tactic} in SAS .

  *** analyse tactic  - -  - -  - -  - -  - -  - -  - -  - -  - -  - -  - - - --
  op analyse_tactic : CITP -> AnalysisAction{CITP} .

  eq analyse L tactic {CT : 'Tactic}
   = return {CT : 'Tactic} .

  eq analyse L tactic {'@crt[TtL] : 'Tactic} in SAS
   = try { '@crt [
        analyse L tactics (TtL) in AnalysisState[L]{head-goal(goal-list(SAS))}
      ] : 'Tactic } .

  eq analyse L tactic {'disj[mdn] : 'Tactic}
   = try { 'disj [
        return (mdn)
      ] : 'Tactic } .

  eq analyse L tactic {'ind[VL] : 'Tactic}
   = try { 'ind [
        analyse L varlist (VL)
      ] : 'Tactic } .

  eq analyse L tactic {'ind-schema[VL] : 'Tactic}
   = try { 'ind-schema [
        analyse L varlist (VL)
      ] : 'Tactic } .

  eq analyse L tactic {'init[mdn, Subst] : 'Tactic}
   = try { 'init [
        return (mdn),
        analyse L substitution (Subst)
      ] : 'Tactic } .

  eq analyse L tactic {'init[md] : 'Tactic}
   = try { 'init [
        return (md)
      ] : 'Tactic } .

  eq analyse L tactic {'subst[Subst] : 'Tactic}
   = try { 'subst [
        analyse L substitution (Subst)
      ] : 'Tactic } .

  eq analyse L tactic {'pull[md] : 'Tactic}
   = try { 'pull [
        return (md)
      ] : 'Tactic } .

  eq analyse L tactic {'push[mdn] : 'Tactic}
   = try { 'push [
        return (mdn)
      ] : 'Tactic } .

  eq analyse L tactic {'select[N] : 'Tactic}
   = try { 'select [
        check L index (N)
      ] : 'Tactic } .

  eq analyse L tactic {T : 'Tactic} in SAS
   = return {T : 'Tactic} in SAS [owise] .

  *** analyse substitution  - - - - - - - - - - - - - - - - - - - - - - - - - --
  op analyse_substitution : CITP -> AnalysisAction{CITP} .

  eq analyse L substitution {'_;_[Subst1, Subst2] : 'Substitution}
   = try { '_;_ [
        analyse L substitution (Subst1),
        analyse L substitution (Subst2)
      ] : 'Substitution } .

  eq analyse L substitution {'_<-_[$V, $T] : 'Substitution}
   = try { '_<-_ [
        analyse L variable ($V),
        analyse L term ($T)
      ] : 'Substitution }
     then check that both L terms have the same kind .

  *** check index  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  op check_index : CITP -> AnalysisAction{CITP} .
  eq check L index (N) in SAS
   = check (read-num(N) :: Nat and-then read-num(N) < size(goal-list(SAS)))
     and-then return (N)
     or-else fail ('not 'a 'valid 'index:
      emph(print term N given tactic-grammar(L)),
      (at term N given tactic-grammar(L), include context))
     in SAS .

  *** analyse command  - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  op analyse_command : CITP -> AnalysisAction{CITP} .

  eq analyse L command {'import_module_[$LN, $MN] : 'Command}
   = try { 'import_module_ [
        analyse L language name ($LN),
        analyse L module name ($MN)
      ] : 'Command } .

  eq analyse L command {'show`module_[$MN] : 'Command}
   = try { 'show`module_ [
        check L module name ($MN)
      ] : 'Command } .

  eq analyse L command {'show`goal_[$GN] : 'Command}
   = try { 'show`goal_ [
        analyse L goal name ($GN)
      ] : 'Command } .

  eq analyse L command {'show`proof_[$PN] : 'Command}
   = try { 'show`proof_ [
        analyse L proof name ($PN)
      ] : 'Command } .

  eq analyse L command {'begin`proof_of_[$PN, $GN] : 'Command}
   = try { 'begin`proof_of_ [
        solve L proof name ($PN),
        analyse L goal name ($GN)
      ] : 'Command } .

  eq analyse L command {Cmd : 'Command}
   = return {Cmd : 'Command} .

  eq analyse L command {Cmd : 'ProofCommand}
   = return {Cmd : 'ProofCommand} .

  eq analyse L command {'reduce`term_[$T] : 'ProofCommand}
   = try {'reduce`term_[analyse L term ($T)] : 'ProofCommand} .

  eq analyse L command {'search`path`from_to_[$T1, $T2] : 'ProofCommand}
   = try { 'search`path`from_to_ [
        analyse L term ($T1),
        analyse L term ($T2)
      ] : 'ProofCommand} .

  *** analyse language name  - - - - - - - - - - - - - - - - - - - - - - - - - -
  op analyse_language`name : CITP -> AnalysisAction{CITP} .
  ceq analyse L language name {$[LN] : 'SpecLang}
   = check (SL is known L spec lang)
     and-then return {LN : 'SpecLang}
     or-else fail ('unknown 'specification 'language: spaced-emph(SL))
   if SL := read-lang-name(L, LN) .

  *** analyse module name  - - - - - - - - - - - - - - - - - - - - - - - - - - -
  op analyse_module`name : CITP -> AnalysisAction{CITP} .
  ceq analyse L module name {$[MN] : 'ModuleName} in SAS
   = return {MN : 'ModuleName} in SAS
   if M := get-module(L, lang-name(SAS), read-module-name(L, MN), db(SAS)) .
  eq analyse L module name {$[MN] : 'ModuleName} in SAS
   = fail ('no 'such 'module: emph(read-module-name(L, MN))) in SAS [owise] .
endfm

********************************************************************************

fmod CITP/PRINTING is
  protecting PRINTING { CITP } .
  protecting CITP/APPLY .
  protecting CITP/SHOW .

  var  L : CITP .
  var  G : Goal{CITP} .
  var  GL : GoalList{CITP} .
  var  NGL : NeGoalList{CITP} .
  var  P : Proof{CITP} .
  var  NPL : NeProofList{CITP} .
  var  TtL : TacticList{CITP} .
  vars M M0 : Module .
  var  N : Nat .

  *** print goal  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
  op print : GoalList{CITP} -> QidList .
  eq print(no-goal) = 'QED .
  eq print(G)
   = print term show-goal(CITP, G) given print-grammar(CITP) .
  eq print(G NGL) = print(G) '\n '\n '--- '\n '\n print(NGL) .

  op print : GoalList{CITP} Module -> QidList .
  eq print(no-goal, M0) = 'QED .
  eq print(G, M0)
   = print term show-goal(CITP, G, M0) given print-grammar(CITP) .
  eq print(G NGL, M0) = print(G, M0) '\n '\n print(NGL, M0) .

  *** print goal list (numbered)  - - - - - - - - - - - - - - - - - - - - - - --
  op print : GoalList{CITP} Nat -> QidList .
  eq print(no-goal, N) = 'QED .
  eq print(G, N)
   = '--- 'goal qid(N) '\n '\n
     (print term show-goal(CITP, G) given print-grammar(CITP)) .
  eq print(G NGL, N) = print(NGL, s N) '\n '\n print(G, N) .

  op print : GoalList{CITP} Module Nat -> QidList .
  eq print(no-goal, M0, N) = 'QED .
  eq  print(G, M0, N)
   = '--- 'goal qid(N) '\n '\n
     (print term show-goal(CITP, G, M0) given print-grammar(CITP)) .
  eq print(G NGL, M0, N) = print(NGL, M0, s N) '\n '\n print(G, M0, N) .

  *** print summary  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  op print-summary : GoalList{CITP} Module -> QidList .
  eq print-summary(no-goal, M0) = 'QED .
  eq print-summary(G, M0)
   = 'One 'remaining 'goal 'to 'prove: '\n '\n
     (print term show-goal(CITP, G, M0) given print-grammar(CITP)) .
  eq print-summary(G NGL, M0)
   = qid(size(G NGL)) 'remaining 'goals 'to 'prove.
     'Here's 'the 'first 'one: '\n '\n
     (print term show-goal(CITP, G, M0) given print-grammar(CITP)) .

  *** print proof  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  op print : ProofList{CITP} -> QidList .
  eq print((nil).ProofList{CITP}) = nil .
  eq print(P)
   = if eval(P) == no-goal then nil else '\! '\y 'incomplete '\o fi
     (print term show-proof(CITP, P) given print-grammar(CITP)) .
  eq print(P NPL) = print(P) '\n '\n '--- '\n '\n print(NPL) .

  *** print tactic list  - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  op print : TacticList{CITP} GoalList{CITP} -> QidList .
  eq print(TtL, GL)
   = print term pack('__, show-tactics(CITP, GL, TtL))
     given tactic-grammar(CITP) .
endfm

********************************************************************************

fmod CITP/PARSING-&-PRINTING is
  protecting CITP/PARSING .
  protecting CITP/PRINTING .
endfm

********************************************************************************
