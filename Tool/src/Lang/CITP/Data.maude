***( SpeX/Lang/CITP

  This file is part of CITP.

  License : GNU General Public License v2.0 or later (GPL-2.0-or-later)
  Authors : Daniel Gaina <daniel@imi.kyushu-u.ac.jp>,
            Ionut Tutu <Ionut.Tutu@imar.ro>,
            Adrian Riesco <ariesco@fdi.ucm.es>

)

sload ../../Database.maude
sload ../../CommonLibs/Term.maude
sload ../Base/Common/Operations.maude
sload ./Bridge.maude

********************************************************************************

fmod CITP/LID is
  sort CITP .
  op CITP : -> CITP [ctor] .
endfm

********************************************************************************

view CITP/Module from TRIV to META-LEVEL is
  sort Elt to Module .
endv

*** ----------------------------------------------------------------------------

fmod CITP/MODULE-DICT is
  protecting CITP/LID .
  including  DICTIONARY { Qid, CITP/Module } *
    (sort KeyValuePair{Qid,CITP/Module} to MDEntry{CITP},
     sort Dict{Qid,CITP/Module} to ModuleDict{CITP},
     op _`[_`] : Dict{Qid,CITP/Module} Qid -> [Module] to search) .
  protecting CITP/BRIDGE/PREAMBLE .

  var L : CITP .
  var MD : ModuleDict{CITP} .
  var M : Module .
  var M? : [Module] .
  var MN : Qid .
  var MV : Variable .

  *** lookup adjustments  - - - - - - - - - - - - - - - - - - - - - - - - - - --
  op _[_] : ModuleDict{CITP} Qid ~> Module [prec 23] .

  ceq MD[MN]
   = if defined(M?) then M? else upModule(MN, true) fi
   if not MN :: Variable /\ M? := lookup(MN, MD) .

  ceq MD[MV] = (th MV is nil sorts none . none none none none none endth)
   if getType(MV) = 'Module .

  eq MD[MN] = (undefined).Module [owise] .

  *** module-names  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
  op module-names : ModuleDict{CITP} -> QidSet .
  eq module-names(empty) = none .
  eq module-names((MN : M, MD)) = MN ; module-names(MD) .
endfm

********************************************************************************

fmod CITP/FORMULA is
  protecting CITP/LID .
  protecting TERM/OPS .
  protecting ATTRIBUTE/OPS .
  protecting CITP/BRIDGE/PREAMBLE .

  var  L : CITP .
  vars T LHS RHS T0 T1 T2 T3 T4 : Term .
  vars GT GT1 GT2 GT3 GT4 : GroundTerm .
  var  S : Sort .
  var  FI : Qid .
  vars F F1 F2 F3 F4 : Formula{CITP} .
  vars FD FD1 FD2 D : FormDecl{CITP} .
  vars FDL FDL1 FDL2 : FormDeclList{CITP} .
  vars NFDL NFDL1 NFDL2 : NeFormDeclList{CITP} .
  vars E1 E2 : Equation .
  vars ES ES1 ES2 : EquationSet .
  vars CD CD1 CD2 : Condition .
  var  EC : EqCondition .
  vars MB1 MB2 : MembAx .
  vars MS MS1 MS2 : MembAxSet .
  vars R1 R2 : Rule .
  vars RS RS1 RS2 : RuleSet .
  var  VS : VariableSet .
  var  NVS : NeVariableSet .
  vars SB SB1 SB2 : Substitution .
  vars AtS AtS1 AtS2 : AttrSet .
  var  N : Nat .
  var  NZ : NzNat .
  vars MD SR : String .
  vars TP TP1 TP2 TP3 TP4 : Type .
  vars ST ST1 ST2 : Sort .
  var  M : Module .

  *** formulas  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
  sort Formula{CITP} .
  ops true false : -> Formula{CITP} [ctor] .
  op _:[_]:_ : Term CITP Sort -> Formula{CITP} [ctor prec 71] .
  op _=[_]=_ : Term CITP Term -> Formula{CITP} [ctor prec 71] .
  op _:[_]=_ : Term CITP Term -> Formula{CITP} [ctor prec 71] .
  op _=[_]>_ : Term CITP Term -> Formula{CITP} [ctor prec 71] .
  op ~_ : Formula{CITP} -> Formula{CITP} [ctor prec 72] .
  op _/\_ : Formula{CITP} Formula{CITP} -> Formula{CITP}
    [ctor assoc prec 73] .
  op _\/_ : Formula{CITP} Formula{CITP} -> Formula{CITP}
    [ctor assoc prec 75] .
  op _if_ : Formula{CITP} Formula{CITP} -> Formula{CITP}
    [ctor gather (E e) prec 77] .
  op forall{_}_ : VariableSet Formula{CITP} -> Formula{CITP}
    [ctor prec 79] .
  op exists{_}_ : VariableSet Formula{CITP} -> Formula{CITP}
    [ctor prec 79] .
  op fmvar : CITP Qid -> Formula{CITP} [ctor] .

  *** formula declarations  - - - - - - - - - - - - - - - - - - - - - - - - - --
  sorts FormDecl{CITP} NeFormDeclList{CITP} FormDeclList{CITP} .
  subsorts FormDecl{CITP} < NeFormDeclList{CITP} < FormDeclList{CITP} .
  op (fm_[_].) : Formula{CITP} AttrSet -> FormDecl{CITP} [ctor] .

  op no-fd : -> FormDeclList{CITP} [ctor] .
  op __ : FormDeclList{CITP} FormDeclList{CITP} -> FormDeclList{CITP}
    [ctor assoc id: no-fd] .
  op __ : NeFormDeclList{CITP} FormDeclList{CITP} -> NeFormDeclList{CITP}
    [ctor ditto] .
  op __ : FormDeclList{CITP} NeFormDeclList{CITP} -> NeFormDeclList{CITP}
    [ctor ditto] .

  *** free variables  - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
  op fv : Formula{CITP} -> VariableSet .
  eq fv(true) = none .
  eq fv(false) = none .
  eq fv(T :[L]: S) = vars(T) .
  eq fv(LHS =[L]= RHS) = vars(LHS) ; vars(RHS) .
  eq fv(LHS :[L]= RHS) = vars(LHS) ; vars(RHS) .
  eq fv(LHS =[L]> RHS) = vars(LHS) ; vars(RHS) .
  eq fv(~ F) = fv(F) .
  eq fv(F1 /\ F2) = fv(F1) ; fv(F2) .
  eq fv(F1 \/ F2) = fv(F1) ; fv(F2) .
  eq fv(F1 if F2) = fv(F1) ; fv(F2) .
  eq fv(forall {VS} F) = fv(F) \ VS .
  eq fv(exists {VS} F) = fv(F) \ VS .
  eq fv(fmvar(L, FI)) = none .

  *** bound variables  - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  op bv : Formula{CITP} -> VariableSet .
  eq bv(true) = none .
  eq bv(false) = none .
  eq bv(T :[L]: S) = none .
  eq bv(LHS =[L]= RHS) = none .
  eq bv(LHS :[L]= RHS) = none .
  eq bv(LHS =[L]> RHS) = none .
  eq bv(~ F) = bv(F) .
  eq bv(F1 /\ F2) = bv(F1) ; bv(F2) .
  eq bv(F1 \/ F2) = bv(F1) ; bv(F2) .
  eq bv(F1 if F2) = bv(F1) ; bv(F2) .
  eq bv(forall {VS} F) = (VS ^ fv(F)) ; bv(F) .
  eq bv(exists {VS} F) = (VS ^ fv(F)) ; bv(F) .
  eq bv(fmvar(L, FI)) = none .

  *** getLB  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  op getLB : Formula{CITP} -> Nat .
  eq getLB(F) = getLB(fv(F) ; bv(F), 0) .

  op getLB : FormDeclList{CITP} -> Nat .
  eq getLB(no-fd) = 0 .
  eq getLB(fm F [AtS] . FDL) = max(getLB(AtS), getLB(FDL)) .

  op getLB : FormDeclList{CITP} String -> Nat .
  eq getLB(no-fd, SR) = 0 .
  eq getLB(fm F [AtS] . FDL, SR) = max(getLB(AtS, SR), getLB(FDL, SR)) .

  *** metadata  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
  op metadata : FormDecl{CITP} -> String .
  eq metadata(fm F [AtS] .) = metadata(AtS) .

  op md-only : FormDeclList{CITP} -> FormDeclList{CITP} .
  eq md-only(no-fd) = no-fd .
  eq md-only(fm F [AtS] . FDL) = (fm F [metadata-attrs(AtS)] .) md-only(FDL) .

  op md-update : FormDeclList{CITP} Substitution Module -> FormDeclList{CITP} .
  eq md-update(no-fd, SB, M) = no-fd .
  eq md-update(fm F [AtS] . FDL, SB, M)
   = (fm F [md-update(AtS, SB, M)] .) md-update(FDL, SB, M) .

  *** substitutions  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  op _<<_ : Formula{CITP} Substitution -> Formula{CITP} [prec 67] .
  eq true << SB = true .
  eq false << SB = false .
  eq (T :[L]: S) << SB = (T << SB) :[L]: S .
  eq (LHS =[L]= RHS) << SB = (LHS << SB) =[L]= (RHS << SB) .
  eq (LHS :[L]= RHS) << SB = (LHS << SB) :[L]= (RHS << SB) .
  eq (LHS =[L]> RHS) << SB = (LHS << SB) =[L]> (RHS << SB) .
  eq (~ F) << SB = ~ (F << SB) .
  eq (F1 /\ F2) << SB = (F1 << SB) /\ (F2 << SB) .
  eq (F1 \/ F2) << SB = (F1 << SB) \/ (F2 << SB) .
  eq (F1 if F2) << SB = (F1 << SB) if (F2 << SB) .
  eq (forall {VS} F) << SB = forall {VS} (F << SB - VS) .
  eq (exists {VS} F) << SB = exists {VS} (F << SB - VS) .
  eq fmvar(L, FI) << SB = fmvar(L, FI) .

  op _<<_ : FormDeclList{CITP} Substitution -> FormDeclList{CITP} .
  eq no-fd << SB = no-fd .
  eq (fm F [AtS] .) << SB = (fm F << SB [AtS] .) .
  eq (NFDL1 NFDL2) << SB = (NFDL1 << SB) (NFDL2 << SB) .

  *** quantified-formula predicates  - - - - - - - - - - - - - - - - - - - - - -
  op _is`universally`quantified : Formula{CITP} -> Bool .
  eq (forall {VS} F) is universally quantified = true .
  eq F is universally quantified = false [owise] .

  op _is`not`universally`quantified : Formula{CITP} -> Bool .
  eq F is not universally quantified = not (F is universally quantified) .

  *** executable formulas  - - - - - - - - - - - - - - - - - - - - - - - - - - -
  op execs : FormDeclList{CITP} -> FormDeclList{CITP} .
  eq execs(no-fd) = no-fd .
  eq execs(fm F [AtS] . FDL)
   = if (F is executable) then (fm F [AtS] .) else no-fd fi execs(FDL) .

  op non-execs : FormDeclList{CITP} -> FormDeclList{CITP} .
  eq non-execs(no-fd) = no-fd .
  eq non-execs(fm F [AtS] . FDL)
   = if (F is executable) then no-fd else (fm F [AtS] .) fi non-execs(FDL) .

  op _is`executable : Formula{CITP} -> Bool .
  eq (T :[L]: S) is executable = true .
  ceq ((T :[L]: S) if F) is executable = true
   if cond-vars(F, vars(T)) :: VariableSet
      /\ F is eqCondition .
  ceq (LHS =[L]= RHS) is executable = true
   if vars(RHS) subset vars(LHS) .
  eq (T1 :[L]= T2) is executable = (T2 =[L]= T1) is executable .
  ceq ((LHS =[L]= RHS) if F) is executable = true
   if vars(RHS) subset cond-vars(F, vars(LHS))
      /\ F is eqCondition .
  ceq (LHS =[L]> RHS) is executable = true
   if vars(RHS) subset vars(LHS) .
  ceq ((LHS =[L]> RHS) if F) is executable = true
   if vars(RHS) subset cond-vars(F, vars(LHS)) .
  eq (forall {VS} F) is executable
   = F is executable .
  eq F is executable = false [owise] .

  op cond-vars : Formula{CITP} VariableSet ~> VariableSet .
  eq cond-vars(true, VS) = VS .
  ceq cond-vars(T :[L]: S, VS) = VS
   if vars(T) subset VS .
  ceq cond-vars(LHS =[L]= RHS, VS) = VS
   if vars(LHS) subset VS /\ vars(RHS) subset VS .
  ceq cond-vars(LHS :[L]= RHS, VS) = VS ; vars(LHS)
   if vars(RHS) subset VS .
  ceq cond-vars(LHS =[L]> RHS, VS) = VS
   if vars(LHS) subset VS /\ vars(RHS) subset VS .
  eq cond-vars(F1 /\ F2, VS) = cond-vars(F2, cond-vars(F1, VS)) .

  op _is`eqCondition : Formula{CITP} -> Bool .
  eq (true) is eqCondition = true .
  eq (T :[L]: S) is eqCondition = true .
  eq (LHS =[L]= RHS) is eqCondition = true .
  eq (LHS :[L]= RHS) is eqCondition = true .
  eq (F1 /\ F2) is eqCondition
   = (F1 is eqCondition) and-then (F2 is eqCondition) .
  eq F is eqCondition = false [owise] .

  *** checking for subterm matches  - - - - - - - - - - - - - - - - - - - - - --
  op xMatch? : Module Formula{CITP} Term -> Bool .
  eq xMatch?(M, true, T0) = false .
  eq xMatch?(M, false, T0) = false .
  eq xMatch?(M, T :[L]: S, T0)
   = metaXmatch(M, T0, T, nil, 0, unbounded, 0) :: MatchPair .
  eq xMatch?(M, LHS =[L]= RHS, T0)
   = metaXmatch(M, T0, LHS, nil, 0, unbounded, 0) :: MatchPair
     or-else metaXmatch(M, T0, RHS, nil, 0, unbounded, 0) :: MatchPair .
  eq xMatch?(M, LHS :[L]= RHS, T0)
   = metaXmatch(M, T0, LHS, nil, 0, unbounded, 0) :: MatchPair
     or-else metaXmatch(M, T0, RHS, nil, 0, unbounded, 0) :: MatchPair .
  eq xMatch?(M, LHS =[L]> RHS, T0)
   = metaXmatch(M, T0, LHS, nil, 0, unbounded, 0) :: MatchPair
     or-else metaXmatch(M, T0, RHS, nil, 0, unbounded, 0) :: MatchPair .
  eq xMatch?(M, ~ F, T0) = xMatch?(M, F, T0) .
  eq xMatch?(M, F1 /\ F2, T0) = xMatch?(M, F1, T0) or-else xMatch?(M, F2, T0) .
  eq xMatch?(M, F1 \/ F2, T0) = xMatch?(M, F1, T0) or-else xMatch?(M, F2, T0) .
  eq xMatch?(M, F1 if F2, T0) = xMatch?(M, F1, T0) or-else xMatch?(M, F2, T0) .
  eq xMatch?(M, forall {VS} F, T0) = xMatch?(M, F, T0) .
  eq xMatch?(M, exists {VS} F, T0) = xMatch?(M, F, T0) .

  *** checking for (simple) circular applications of conditional equations  - --
  op circular : Module Formula{CITP} -> Bool .
  eq circular(M, (T :[L]: S) if F) = xMatch?(M, F, T) .
  eq circular(M, (LHS =[L]= RHS) if F) = xMatch?(M, F, LHS) .
  eq circular(M, forall {VS} F) = circular(M, F) .
  eq circular(M, F) = false [owise] .

  *** conditions to formulas  - - - - - - - - - - - - - - - - - - - - - - - - --
  op c2f : CITP Condition -> Formula{CITP} .
  eq c2f(L, nil) = true .
  eq c2f(L, T : S /\ CD) = (T :[L]: S) /\ c2f(L, CD) .
  eq c2f(L, LHS = RHS /\ CD) = (LHS =[L]= RHS) /\ c2f(L, CD) .
  eq c2f(L, LHS := RHS /\ CD) = (LHS :[L]= RHS) /\ c2f(L, CD) .
  eq c2f(L, LHS => RHS /\ CD) = (LHS =[L]> RHS) /\ c2f(L, CD) .

  *** formulas to conditions  - - - - - - - - - - - - - - - - - - - - - - - - --
  op f2c : Formula{CITP} ~> Condition .
  eq f2c(true) = nil .
  eq f2c(T :[L]: S) = (T : S) .
  eq f2c(LHS =[L]= RHS) = (LHS = RHS) .
  eq f2c(LHS :[L]= RHS) = (LHS := RHS) .
  eq f2c(LHS =[L]> RHS) = (LHS => RHS) .
  ceq f2c(F1 /\ F2) = CD1 /\ CD2
   if CD1 := f2c(F1) /\ CD2 := f2c(F2) .

  *** equations to formula declarations  - - - - - - - - - - - - - - - - - - - -
  op eq2fm : CITP EquationSet -> FormDeclList{CITP} .
  eq eq2fm(L, none) = no-fd .
  eq eq2fm(L, E1 E2 ES) = eq2fm(L, E1) eq2fm(L, E2 ES) .
  eq eq2fm(L, eq LHS = RHS [AtS] .) = (fm LHS =[L]= RHS [AtS] .) .
  eq eq2fm(L, ceq LHS = RHS if EC [AtS] .)
   = (fm (LHS =[L]= RHS) if c2f(L, EC) [AtS] .) .

  *** formula declarations to equations  - - - - - - - - - - - - - - - - - - - -
  op fm2eq : FormDeclList{CITP} ~> EquationSet .
  eq fm2eq(no-fd) = none .
  eq fm2eq(NFDL1 NFDL2) = fm2eq(NFDL1) fm2eq(NFDL2) .
  eq fm2eq(fm LHS =[L]= RHS [AtS] .) = (eq LHS = RHS [AtS] .) .
  eq fm2eq(fm LHS :[L]= RHS [AtS] .) = (eq RHS = LHS [AtS] .) .
  ceq fm2eq(fm (LHS =[L]= RHS) if F [AtS] .) = (ceq LHS = RHS if EC [AtS] .)
   if EC := f2c(F) .
  ceq fm2eq(fm (LHS :[L]= RHS) if F [AtS] .) = (ceq RHS = LHS if EC [AtS] .)
   if EC := f2c(F) .
  ceq fm2eq(fm F1 /\ F2 [AtS] .) = ES1 ES2
   if ES1 := fm2eq(fm F1 [md-update(AtS, "[lhs]")] .)
      /\ ES2 := fm2eq(fm F2 [md-update(AtS, "[rhs]")] .) .
  ceq fm2eq(fm forall {VS} F [AtS] .) = ES if ES := fm2eq(fm F [AtS] .) .

  *** membership axioms to formula declarations  - - - - - - - - - - - - - - - -
  op mb2fm : CITP MembAxSet -> FormDeclList{CITP} .
  eq mb2fm(L, none) = no-fd .
  eq mb2fm(L, MB1 MB2 MS) = mb2fm(L, MB1) mb2fm(L, MB2 MS) .
  eq mb2fm(L, mb T : S [AtS] .) = (fm T :[L]: S [AtS] .) .
  eq mb2fm(L, cmb T : S if EC [AtS] .)
   = (fm (T :[L]: S) if c2f(L, EC) [AtS] .) .

  *** formula declarations to membership axioms  - - - - - - - - - - - - - - - -
  op fm2mb : FormDeclList{CITP} ~> MembAxSet .
  eq fm2mb(no-fd) = none .
  eq fm2mb(NFDL1 NFDL2) = fm2mb(NFDL1) fm2mb(NFDL2) .
  eq fm2mb(fm T :[L]: S [AtS] .) = (mb T : S [AtS] .) .
  ceq fm2mb(fm (T :[L]: S) if F [AtS] .) = (cmb T : S if EC [AtS] .)
   if EC := f2c(F) .
  ceq fm2mb(fm F1 /\ F2 [AtS] .) = MS1 MS2 *** lost attributes here
   if MS1 := fm2mb(fm F1 [none] .) /\ MS2 := fm2mb(fm F2 [none] .) .
  ceq fm2mb(fm forall {VS} F [AtS] .) = MS if MS := fm2mb(fm F [AtS] .) .

  *** rules to formula declarations  - - - - - - - - - - - - - - - - - - - - - -
  op rl2fm : CITP RuleSet -> FormDeclList{CITP} .
  eq rl2fm(L, none) = no-fd .
  eq rl2fm(L, R1 R2 RS) = rl2fm(L, R2 RS) rl2fm(L, R2 RS) .
  eq rl2fm(L, rl LHS => RHS [AtS] .) = (fm LHS =[L]> RHS [AtS] .) .
  eq rl2fm(L, crl LHS => RHS if CD [AtS] .)
   = (fm (LHS =[L]> RHS) if c2f(L, CD) [AtS] .) .

  *** formula declarations to rules  - - - - - - - - - - - - - - - - - - - - - -
  op fm2rl : FormDeclList{CITP} ~> RuleSet .
  eq fm2rl(no-fd) = none .
  eq fm2rl(NFDL1 NFDL2) = fm2rl(NFDL1) fm2rl(NFDL2) .
  eq fm2rl(fm LHS =[L]> RHS [AtS] .) = (rl LHS => RHS [AtS] .) .
  ceq fm2rl(fm (LHS =[L]> RHS) if F [AtS] .) = (crl LHS => RHS if CD [AtS] .)
   if CD := f2c(F) .
  ceq fm2rl(fm F1 /\ F2 [AtS] .) = RS1 RS2 *** lost attributes here
   if RS1 := fm2rl(fm F1 [none] .) /\ RS2 := fm2rl(fm F2 [none] .) .
  ceq fm2rl(fm forall {VS} F [AtS] .) = RS if RS := fm2rl(fm F [AtS] .) .

  *** get terms from formulas  - - - - - - - - - - - - - - - - - - - - - - - - -
  op getTM : Formula{CITP} -> TermList .
  eq getTM(true) = empty .
  eq getTM(false) = empty .
  eq getTM(T :[L]: S) = T .
  eq getTM(LHS =[L]= RHS) = LHS, RHS .
  eq getTM(LHS :[L]= RHS) = LHS, RHS .
  eq getTM(LHS =[L]> RHS) = LHS, RHS .
  eq getTM(~ F) = getTM(F) .
  eq getTM(F1 /\ F2) = getTM(F1), getTM(F2) .
  eq getTM(F1 \/ F2) = getTM(F1), getTM(F2) .
  eq getTM(F1 if F2) = getTM(F1), getTM(F2) .
  eq getTM(forall {VS} F) = getTM(F) .
  eq getTM(exists {VS} F) = getTM(F) .
  eq getTM(fmvar(L, FI)) = empty .

  op getTM : FormDeclList{CITP} -> TermList .
  eq getTM(no-fd) = empty .
  eq getTM(FD NFDL) = getTM(FD), getTM(NFDL) .
  eq getTM(fm F [AtS] .) = getTM(F) .

  *** get ground terms from formulas  - - - - - - - - - - - - - - - - - - - - --
  op getGT : Formula{CITP} -> GroundTermList .
  eq getGT(true) = empty .
  eq getGT(false) = empty .
  eq getGT(T :[L]: S)
   = if T :: GroundTerm then T else empty fi .
  eq getGT(LHS =[L]= RHS)
   = if LHS :: GroundTerm then LHS else empty fi,
     if RHS :: GroundTerm then RHS else empty fi .
  eq getGT(LHS :[L]= RHS)
   = if LHS :: GroundTerm then LHS else empty fi,
     if RHS :: GroundTerm then RHS else empty fi .
  eq getGT(LHS =[L]> RHS)
   = if LHS :: GroundTerm then LHS else empty fi,
     if RHS :: GroundTerm then RHS else empty fi .
  eq getGT(~ F) = getGT(F) .
  eq getGT(F1 /\ F2) = getGT(F1), getGT(F2) .
  eq getGT(F1 \/ F2) = getGT(F1), getGT(F2) .
  eq getGT(F1 if F2) = getGT(F1), getGT(F2) .
  eq getGT(forall {VS} F) = getGT(F) .
  eq getGT(exists {VS} F) = getGT(F) .
  eq getGT(fmvar(L, FI)) = empty .

  op getGT : FormDeclList{CITP} -> GroundTermList .
  eq getGT(no-fd) = empty .
  eq getGT(FD NFDL) = getGT(FD), getGT(NFDL) .
  eq getGT(fm F [AtS] .) = getGT(F) .

  *** keep formulas with a given left-hand side  - - - - - - - - - - - - - - - -
  op getFD : FormDeclList{CITP} Term -> FormDeclList{CITP} .
  eq getFD(no-fd, T) = no-fd .
  eq getFD(fm (LHS =[L]= RHS) if F [AtS] . FDL, LHS)
   = fm (LHS =[L]= RHS) if F [AtS] . getFD(FDL, LHS) .
  eq getFD(fm (LHS :[L]: S) if F [AtS] . FDL, LHS)
   = fm (LHS :[L]: S) if F [AtS] . getFD(FDL, LHS) .
  eq getFD(fm (LHS =[L]> RHS) if F [AtS] . FDL, LHS)
   = fm (LHS =[L]> RHS) if F [AtS] . getFD(FDL, LHS) .
  eq getFD(FD FDL, LHS) = getFD(FDL, LHS) [owise] .

  *** remove formulas with a given left-hand side  - - - - - - - - - - - - - - -
  op rmFD : FormDeclList{CITP} Term -> FormDeclList{CITP} .
  eq rmFD(no-fd, LHS) = no-fd .
  eq rmFD(fm (LHS :[L]: S) if F [AtS] . FDL, LHS) = rmFD(FDL, LHS) .
  eq rmFD(fm (LHS =[L]= RHS) if F [AtS] . FDL, LHS) = rmFD(FDL, LHS) .
  eq rmFD(fm (LHS =[L]> RHS) if F[ AtS] . FDL, LHS) = rmFD(FDL, LHS) .
  eq rmFD(FD FDL, LHS) = FD rmFD(FDL, LHS) [owise] .

  *** lookup formula declaration  - - - - - - - - - - - - - - - - - - - - - - --
  op _[_] : FormDeclList{CITP} Nat -> FormDeclList{CITP} .
  eq no-fd[N] = no-fd .
  eq (FD FDL)[0] = FD .
  eq (FD FDL)[NZ] = FDL[sd(NZ, 1)] .

  op _[_] : FormDeclList{CITP} String -> FormDeclList{CITP} .
  eq no-fd[SR] = no-fd .
  eq (fm F [metadata(SR) AtS] . FDL)[SR]
   = (fm F [metadata(SR) AtS] .) (FDL[SR]) .
  eq (FD FDL)[SR] = FDL[SR] [owise] .

  *** remove formula declaration  - - - - - - - - - - - - - - - - - - - - - - --
  op rm : FormDeclList{CITP} Nat -> FormDeclList{CITP} .
  eq rm(no-fd, N) = no-fd .
  eq rm(FD FDL, 0) = FDL .
  eq rm(FD FDL, NZ) = FD rm(FDL, sd(NZ, 1)) .

  op rm : FormDeclList{CITP} String -> FormDeclList{CITP} .
  eq rm(no-fd, SR) = no-fd .
  eq rm(fm F [metadata(SR) AtS] . FDL, SR) = rm(FDL, SR) .
  eq rm(FD FDL, SR) = FD rm(FDL, SR) [owise] .

  *** metadata updates  - - - - - - - - - - - - - - - - - - - - - - - - - - - --
  op md-update : FormDeclList{CITP} String -> FormDeclList{CITP} .
  eq md-update(no-fd, SR) = no-fd .
  eq md-update(fm F [AtS] ., SR) = (fm F [md-update(AtS, SR)] .) .
  eq md-update(NFDL1 NFDL2, SR) = md-update(NFDL1, SR) md-update(NFDL2, SR) .

  *** occurs  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
  op occurs : FormDecl{CITP} FormDeclList{CITP} -> Bool .
  eq occurs(D, no-fd) = false .
  eq occurs(D, FD FDL) = same-formula(D, FD) or-else occurs(D, FDL) .

  op same-formula : FormDecl{CITP} FormDecl{CITP} -> Bool .
  eq same-formula(fm F [AtS1] ., fm F [AtS2] .) = true .
  eq same-formula(FD1, FD2) = false [owise] .

  op _\_ : FormDeclList{CITP} FormDeclList{CITP} -> FormDeclList{CITP} .
  eq no-fd \ FDL = no-fd .
  eq (FD1 FDL1) \ FDL2
   = if occurs(FD1, FDL2) then no-fd else FD1 fi (FDL1 \ FDL2) .

  *** strip  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  op strip : FormDeclList{CITP} -> FormDeclList{CITP} .
  eq strip(no-fd) = no-fd .
  eq strip(NFDL1 NFDL2) = strip(NFDL1) strip(NFDL2) .
  eq strip(fm forall {NVS} F [AtS] .) = strip(fm F [AtS] .) .
  eq strip(FD) = FD [owise] .

  *** extract (if possible) an unification problem from a given formula  - - - -
  op unif-problem : Formula{CITP} ~> UnificationProblem .
  eq unif-problem(LHS =[L]= RHS) = LHS =? RHS .
  eq unif-problem(LHS :[L]= RHS) = LHS =? RHS .
  eq unif-problem(F1 /\ F2) = unif-problem(F1) /\ unif-problem(F2) .
  eq unif-problem(exists {VS} F) = unif-problem(F) .

  *** match formulas (partially defined)  - - - - - - - - - - - - - - - - - - --
  op match? : Module Formula{CITP} Formula{CITP} ~> Substitution .
  *** for atoms
  eq match?(M, true, true)  = (none).Substitution .
  eq match?(M, false, false)= (none).Substitution .
  ceq match?(M, T1 =[L]= T2, T3 =[L]= T4) = SB1 ; SB2
   if TP1 := getType(metaNormalize(M, T1))
      /\ TP2 := getType(metaNormalize(M, T3))
      /\ sameKind(M, TP1, TP2)
      /\ TP3 := getType(metaNormalize(M, T2))
      /\ TP4 := getType(metaNormalize(M, T4))
      /\ sameKind(M, TP3, TP4)
      /\ SB1 := metaMatch(M, T1, T3, nil, 0)
      /\ SB2 := metaMatch(M, T2, T4, nil, 0)
      /\ clash(SB1, SB2) = false .
  ceq match?(M, T1 =[L]= T2, T3 =[L]= T4) = SB1 ; SB2
   if TP1 := getType(metaNormalize(M, T1))
      /\ TP2 := getType(metaNormalize(M, T4))
      /\ sameKind(M, TP1, TP2)
      /\ TP3 := getType(metaNormalize(M, T2))
      /\ TP4 := getType(metaNormalize(M, T3))
      /\ sameKind(M, TP3, TP4)
      /\ SB1 := metaMatch(M, T1, T4, nil, 0)
      /\ SB2 := metaMatch(M, T2, T3, nil, 0)
      /\ clash(SB1, SB2) = false .
  ceq match?(M, T1 :[L]= T2, T3 :[L]= T4) = SB1 ; SB2
   if TP1 := getType(metaNormalize(M, T1))
      /\ TP2 := getType(metaNormalize(M, T3))
      /\ sameKind(M, TP1, TP2)
      /\ TP3 := getType(metaNormalize(M, T2))
      /\ TP4 := getType(metaNormalize(M, T4))
      /\ sameKind(M, TP3, TP4)
      /\ SB1 := metaMatch(M, T1, T3, nil, 0)
      /\ SB2 := metaMatch(M, T2, T4, nil, 0)
      /\ clash(SB1, SB2) = false .
  ceq match?(M, T1 =[L]> T2, T3 =[L]> T4) = SB1 ; SB2
   if TP1 := getType(metaNormalize(M, T1))
      /\ TP2 := getType(metaNormalize(M, T3))
      /\ sameKind(M, TP1, TP2)
      /\ TP3 := getType(metaNormalize(M, T2))
      /\ TP4 := getType(metaNormalize(M, T4))
      /\ sameKind(M, TP3, TP4)
      /\ SB1 := metaMatch(M, T1, T3, nil, 0)
      /\ SB2 := metaMatch(M, T2, T4, nil, 0)
      /\ clash(SB1, SB2) = false .
  ceq match?(M, T1 :[L]: ST1, T2 :[L]: ST2) = SB
   if TP1 := getType(metaNormalize(M, T1))
      /\ TP2 := getType(metaNormalize(M, T2))
      /\ sameKind(M, TP1, TP2)
      /\ sortLeq(M, ST2, ST1)
      /\ SB := metaMatch(M, T1, T2, nil, 0) .
  eq match?(M, T1 =[L]= T2, T3 :[L]= T4)
   = match?(M, T1 =[L]= T2, T3 =[L]= T4) .
  *** for negations
  eq match?(M, ~ F1, ~ F2)= match?(M, F1, F2) .
  *** for conjunctions
  ceq match?(M, F1 /\ F2, F3 /\ F4)= SB1 ; SB2
   if SB1 := match?(M, F1, F3)
      /\ SB2 := match?(M, F2, F4)
      /\ clash(SB1, SB2) = false .
  *** for disjunctions
  ceq match?(M, F1 \/ F2, F3 \/ F4)= SB1 ; SB2
   if SB1 := match?(M, F1, F3)
      /\ SB2 := match?(M, F2, F4)
      /\ clash(SB1, SB2) = false .
  *** for implications
  ceq match?(M, F1 if F2, F3 if F4)= SB1 ; SB2
   if SB1 := match?(M, F1, F3)
      /\ SB2 := match?(M, F2, F4)
      /\ clash(SB1, SB2) = false .
  *** for universal quantification
  eq match?(M, forall{VS} F1, F2)= match?(M, F1, F2) .
  eq match?(M, F1, forall{VS} F2)= match?(M, F1, F2) .
endfm

*** ----------------------------------------------------------------------------

fmod CITP/GOAL is
  protecting CITP/FORMULA .

  var  L : CITP .
  vars G G1 G2 : Goal{CITP} .
  vars GL GL1 GL2 : GoalList{CITP} .
  vars NGL1 NGL2 : NeGoalList{CITP} .
  var  SGL : Seq{GoalList{CITP}} .
  var  NSGL : NeSeq{GoalList{CITP}} .
  vars GN GN' : Qid .
  vars  GA MA : QidList .
  vars M M' : Module .
  vars H H1 H2 H' C C1 C2 C' : FormDeclList{CITP} .
  var  F : Formula{CITP} .
  var  T : Term .
  var  GT : GroundTerm .
  vars AtS AtS1 AtS2 : AttrSet .
  var  N : Nat .
  var  NZ : NzNat .

  *** Goal{CITP} and GoalList{CITP}  - - - - - - - - - - - - - - - - - - - - - -
  sorts Goal{CITP} NeGoalList{CITP} GoalList{CITP} .
  subsorts Goal{CITP} < NeGoalList{CITP} < GoalList{CITP} .
  op goal_[_]is_|-{_[_]}_endg : Qid QidList
    FormDeclList{CITP} Module QidList  FormDeclList{CITP} -> Goal{CITP}
    [format (d s d d d s n++i n--i d d d d d d n++i n--i d)] .
  op no-goal : -> GoalList{CITP} [ctor] .
  op __ : GoalList{CITP} GoalList{CITP} -> GoalList{CITP}
    [ctor assoc id: no-goal format (d ni d)] .
  op __ : NeGoalList{CITP} GoalList{CITP} -> NeGoalList{CITP} [ctor ditto] .
  op __ : GoalList{CITP} NeGoalList{CITP} -> NeGoalList{CITP} [ctor ditto] .

  sorts NeSeq{GoalList{CITP}} Seq{GoalList{CITP}} .
  subsorts NeSeq{GoalList{CITP}} < Seq{GoalList{CITP}} .
  op no-gl : -> Seq{GoalList{CITP}} [ctor] .
  op _. : GoalList{CITP} -> NeSeq{GoalList{CITP}} [ctor] .
  op __ : Seq{GoalList{CITP}} Seq{GoalList{CITP}} -> Seq{GoalList{CITP}}
    [ctor assoc id: no-gl] .
  op __ : NeSeq{GoalList{CITP}} Seq{GoalList{CITP}} -> NeSeq{GoalList{CITP}}
    [ctor ditto] .
  op __ : Seq{GoalList{CITP}} NeSeq{GoalList{CITP}} -> NeSeq{GoalList{CITP}}
    [ctor ditto] .

  *** name  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
  op name : Goal{CITP} -> Qid .
  eq name(goal GN[GA] is H |-{M[MA]} C endg) = GN .

  *** module  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
  op module : Goal{CITP} -> Module .
  eq module(goal GN[GA] is H |-{M[MA]} C endg) = M .

  op current-module : GoalList{CITP} -> Module .
  eq current-module(G GL) = module(G) .
  eq current-module(GL)
   = (fmod 'EMPTY is nil sorts none . none none none none endfm) [owise] .

  op current-module : Seq{GoalList{CITP}} -> Module .
  eq current-module(SGL GL .) = current-module(GL) .
  eq current-module(SGL) = current-module(no-goal) [owise] .

  *** premises  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
  op premises : Goal{CITP} -> FormDeclList{CITP} .
  eq premises(goal GN[GA] is H |-{M[MA]} C endg) = H .

  op current-premises : GoalList{CITP} -> FormDeclList{CITP} .
  eq current-premises(G GL) = premises(G) .
  eq current-premises(GL) = no-fd [owise] .

  *** head-goal  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  op head-goal : GoalList{CITP} -> GoalList{CITP} .
  eq head-goal(G GL) = G .
  eq head-goal(GL) = no-goal [owise] .

  *** init  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
  op init : Seq{GoalList{CITP}} -> Seq{GoalList{CITP}} .
  eq init(NSGL GL .) = NSGL .
  eq init(SGL) = SGL [owise] .

  *** last list  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  op last-list : Seq{GoalList{CITP}} -> GoalList{CITP} .
  eq last-list(SGL GL .) = GL .
  eq last-list(SGL) = no-goal [owise] .

  *** size  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
  op size : GoalList{CITP} -> Nat .
  eq size(no-goal) = 0 .
  eq size(G GL) = s size(GL) .

  op size : Seq{GoalList{CITP}} -> Nat .
  eq size(no-gl) = 0 .
  eq size(GL . SGL) = s size(SGL) .

  *** lookup goal  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  op _[_] : GoalList{CITP} Nat -> GoalList{CITP} .
  eq no-goal[N] = no-goal .
  eq (G GL)[0] = G .
  eq (G GL)[NZ] = GL[sd(NZ, 1)] .

  *** remove goal  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  op rm : GoalList{CITP} Nat -> GoalList{CITP} .
  eq rm(no-goal, N) = no-goal .
  eq rm(G GL, 0) = GL .
  eq rm(G GL, NZ) = G rm(GL, sd(NZ, 1)) .
endfm

*** ----------------------------------------------------------------------------

fmod CITP/GOAL/SIMP is
  including CITP/GOAL .

  var  L : CITP .
  vars Q GN : Qid .
  vars GA MA : QidList .
  vars H H1 H2 H3 C C1 C2 : FormDeclList{CITP} .
  var  M : Module .
  vars LHS RHS T T1 T2 T3 : Term .
  var  GT : GroundTerm .
  var  VS : VariableSet .
  vars F F' F1 F2 F3 F4 : Formula{CITP} .
  var  ES : EquationSet .
  var  EC : EqCondition .
  var  RC : Condition .
  vars AtS AtS' AtS1 AtS2 : AttrSet .

  *** equation simplifications  - - - - - - - - - - - - - - - - - - - - - - - --
  eq (T = T) = nil .
  eq (T := T) = nil .
  eq (ceq LHS = RHS if nil [AtS] .) = (eq LHS = RHS [AtS] .) .
  eq (eq T = T [AtS] .) = none .
  eq (ceq T = T if EC [AtS] .) = none .

  *** rule simplification  - - - - - - - - - - - - - - - - - - - - - - - - - - -
  eq (T => T) = nil .
  eq (rl T => T [AtS] .) = none .
  eq (crl T => T if RC [AtS] .) = none .

  *** formula simplifications  - - - - - - - - - - - - - - - - - - - - - - - - -
  eq T =[L]= T = true .
  eq T :[L]= T = true .
  eq T =[L]> T = true .
  eq true if F = true .
  eq F if false = true .
  eq F if true = F .
  eq ~ true = false .
  eq ~ false = true .
  eq ~ ~ F = F .
  eq F /\ true = F .
  eq true /\ F = F .
  eq F \/ false = F .
  eq false \/ F = F .
  eq F \/ true = true .
  eq true \/ F = true .
  eq F /\ false = false .
  eq false /\ F = false .
  eq forall {VS} true = true .
  eq exists {VS} false = false .
  eq forall {none} F = F .
  eq exists {none} F = F .

  *** goal simplifications  - - - - - - - - - - - - - - - - - - - - - - - - - --
  eq goal GN[GA] is H |-{M[MA]} no-fd endg = no-goal .
  eq goal GN[GA] is H |-{M[MA]} C1 fm true [AtS] . C2 endg
   = goal GN[GA] is H |-{M[MA]} C1 C2 endg .
  ceq goal GN[GA] is H |-{M[MA]} C1 fm false [AtS] . C2 endg
   = goal GN[GA] is H |-{M[MA]} fm false [AtS] . endg
   if C1 C2 =/= no-fd .
  eq goal GN[GA] is H1 fm true [AtS] . H2 |-{M[MA]} C endg
   = goal GN[GA] is H1 H2 |-{M[MA]} C endg .
  eq goal GN[GA] is H1 fm false [AtS] . H2 |-{M[MA]} C endg
   = no-goal .
  eq goal GN[GA] is
       H1 fm F [AtS] . H2
     |-{M[MA]}
       C1 fm F [AtS'] . C2
     endg = goal GN[GA] is H1 fm F [AtS] . H2 |-{M[MA]} C1 C2 endg .
  ceq goal GN[GA] is H |-{M[MA]} fm (T =[L]> GT) [AtS] . endg = no-goal
   if metaSearchPath(M, T, GT, nil, '*, unbounded, 0) :: Trace .
  ceq goal GN[GA] is H1 fm F [AtS] . H2 |-{M[MA]} C1 fm F' [AtS'] . C2 endg
   = goal GN[GA] is H1 fm F [AtS] . H2 |-{M[MA]} C1 C2 endg
   if match?(M, F, F') : Substitution .

  *** contradictions  - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
  eq goal GN[GA] is
       H1 fm ('true.Bool  =[CITP]= 'false.Bool) [AtS] . H2
     |-{M[MA]} C endg = no-goal .
  eq goal GN[GA] is
       H1 fm ('false.Bool =[CITP]= 'true.Bool) [AtS] . H2
     |-{M[MA]} C endg = no-goal .
  ceq goal GN[GA] is H |-{M[MA]} C endg = no-goal if consistent(M) = false .
  *** search contradicts premise
  ceq goal GN[GA] is
        H1 fm ~ T =[CITP]> GT [AtS] . H2
     |-{M[MA]} C endg = no-goal
   if metaSearch(M, T, GT, nil, '*, 100000, 0) : ResultTriple .
  *** contradicting premises
  ceq goal GN[GA] is
       H1 fm ~ F1 [AtS1] . H2 fm F2 [AtS2] . H3
     |-{M[MA]} C endg = no-goal
   if match?(M, F1, F2) : Substitution .
  *** negation in premise & modus ponens
  ceq goal GN[GA] is
       H1 fm ~ F [AtS] . H2
     |-{M[MA]} C1 fm F1 if F2 [AtS'] . C2 endg
   = goal GN[GA] is H1 fm ~ F [AtS] . H2 |-{M[MA]} C1 C2 endg
   if match?(M, F, F2) : Substitution .
  ---
  ceq goal GN[GA] is
       H1 fm ~ F [AtS] . H2
     |-{M[MA]} C1 fm F1 if F2 /\ F3 [AtS'] . C2 endg
   = goal GN[GA] is H1 fm ~ F [AtS] . H2 |-{M[MA]} C1 C2 endg
   if match?(M, F, F2) :: Substitution
      or match?(M, F, F3) :: Substitution .
  *** negation in module & modus ponens
  ceq goal GN[GA] is H |-{M[MA]} C1 fm F if F1 [AtS] . C2 endg
   = goal GN[GA] is H |-{M[MA]} C1 C2 endg
   if (eq Q[T1, T2] = 'false.Bool [AtS1] .) ES := getNE(M)
       /\ match?(M, T1 =[CITP]= T2, F1) :: Substitution .
  ---
  ceq goal GN[GA] is H |-{M[MA]} C1 fm F if F1 /\ F2[AtS] . C2 endg
   = goal GN[GA] is H |-{M[MA]} C1 C2 endg
   if (eq Q[T1, T2] = 'false.Bool [AtS1] .) ES := getNE(M)
      /\ match?(M, T1 =[CITP]= T2, F1) :: Substitution
      or match?(M, T1 =[CITP]= T2, F2) :: Substitution .
  *** negation in module contradicts hypothesis
  ceq goal GN[GA] is H1 fm F[AtS] . H2 |-{M[MA]} C endg = no-goal
   if (eq Q[T1, T2] = 'false.Bool [AtS1] .) ES := getNE(M)
      /\ match?(M, T1 =[CITP]= T2, F) : Substitution .
endfm

*** ----------------------------------------------------------------------------

view CITP/Goal from TRIV to CITP/GOAL is
  sort Elt to Goal{CITP} .
endv

*** ----------------------------------------------------------------------------

fmod CITP/GOAL-DICT is
  protecting DICTIONARY { Qid, CITP/Goal } *
    (sort KeyValuePair{Qid,CITP/Goal} to GDEntry{CITP},
     sort Dict{Qid,CITP/Goal} to GoalDict{CITP}) .

  var GD : GoalDict{CITP} .
  var G : Goal{CITP} .
  var GN : Qid .

  *** goal-names  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
  op goal-names : GoalDict{CITP} -> QidSet .
  eq goal-names(empty) = none .
  eq goal-names((GN : G, GD)) = GN ; goal-names(GD) .

  *** goal-list  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  op list : GoalDict{CITP} -> GoalList{CITP} .
  eq list(empty) = no-goal .
  eq list((GN : G, GD)) = G list(GD) .
endfm

********************************************************************************

fmod CITP/TACTIC is
  protecting CITP/LID .
  protecting QID-LIST/OPS .
  protecting QID/CONVERSION .
  protecting META-LEVEL .

  var  L : CITP .
  var  Tt : Tactic{CITP} .
  var  TtL : TacticList{CITP} .
  var  STtL : Seq{TacticList{CITP}} .
  vars MN GN V QI : Qid .
  var  NVL : NeQidList .
  var  QIL : QidList .
  var  SB : Substitution .
  var  SR : String .
  var  N : Nat .

  *** tactics, functorial tactics, and tactic lists  - - - - - - - - - - - - - -
  sorts FunTactic{CITP} Tactic{CITP} .
  subsorts FunTactic{CITP} < Tactic{CITP} .
  sorts NeTacticList{CITP} TacticList{CITP} .
  subsorts Tactic{CITP} < NeTacticList{CITP} < TacticList{CITP} .
  op Tactic[_]{split} : CITP -> FunTactic{CITP} [ctor] .
  op Tactic[_]{@crt_} : CITP TacticList{CITP} -> Tactic{CITP} [ctor] .
  op Tactic[_]{reduce} : CITP -> FunTactic{CITP} [ctor] .
  op Tactic[_]{simp} : CITP -> Tactic{CITP} [ctor] .
  op Tactic[_]{red} : CITP -> FunTactic{CITP} [ctor] .
  op Tactic[_]{imp} : CITP -> FunTactic{CITP} [ctor] .
  op Tactic[_]{conj} : CITP -> FunTactic{CITP} [ctor] .
  op Tactic[_]{disj_} : CITP Nat -> FunTactic{CITP} [ctor] .
  op Tactic[_]{disj_} : CITP String -> FunTactic{CITP} [ctor] .
  op Tactic[_]{tc} : CITP -> FunTactic{CITP} [ctor] .
  op Tactic[_]{sk} : CITP -> FunTactic{CITP} [ctor] .
  op Tactic[_]{ca} : CITP -> FunTactic{CITP} [ctor] .
  op Tactic[_]{ca-rev} : CITP -> FunTactic{CITP} [ctor] .
  op Tactic[_]{cs} : CITP -> FunTactic{CITP} [ctor] .
  op Tactic[_]{trans} : CITP -> FunTactic{CITP} [ctor] .
  op Tactic[_]{ind_} : CITP NeQidList -> FunTactic{CITP} [ctor] .
  op Tactic[_]{ind-schema_} : CITP NeQidList -> FunTactic{CITP} [ctor] .
  op Tactic[_]{init_,_} : CITP String Substitution -> FunTactic{CITP} [ctor] .
  op Tactic[_]{init_,_} : CITP Nat Substitution -> FunTactic{CITP} [ctor] .
  op Tactic[_]{init_} : CITP String -> FunTactic{CITP} [ctor] .
  op Tactic[_]{init-all} : CITP -> FunTactic{CITP} [ctor] .
  op Tactic[_]{subst_} : CITP Substitution -> FunTactic{CITP} [ctor] .
  op Tactic[_]{pull_} : CITP String -> FunTactic{CITP} [ctor] .
  op Tactic[_]{push_} : CITP String -> FunTactic{CITP} [ctor] .
  op Tactic[_]{push_} : CITP Nat -> FunTactic{CITP} [ctor] .
  op Tactic[_]{push-all} : CITP -> FunTactic{CITP} [ctor] .
  op Tactic[_]{select_} : CITP Nat -> Tactic{CITP} [ctor] .
  op Tactic[_]{pass} : CITP -> Tactic{CITP} [ctor] .

  op idle : -> TacticList{CITP} [ctor] .
  op __ : TacticList{CITP} TacticList{CITP} -> TacticList{CITP}
    [ctor assoc id: idle] .
  op __ : NeTacticList{CITP} TacticList{CITP} -> NeTacticList{CITP}
    [ctor ditto] .
  op __ : TacticList{CITP} NeTacticList{CITP} -> NeTacticList{CITP}
    [ctor ditto] .

  sorts NeSeq{TacticList{CITP}} Seq{TacticList{CITP}} .
  subsorts NeSeq{TacticList{CITP}} < Seq{TacticList{CITP}} .
  op no-tl : -> Seq{TacticList{CITP}} [ctor] .
  op _. : TacticList{CITP} -> NeSeq{TacticList{CITP}} [ctor] .
  op __ : Seq{TacticList{CITP}} Seq{TacticList{CITP}}
    -> Seq{TacticList{CITP}} [ctor assoc id: no-tl] .
  op __ : NeSeq{TacticList{CITP}} Seq{TacticList{CITP}}
    -> NeSeq{TacticList{CITP}} [ctor ditto] .
  op __ : Seq{TacticList{CITP}} NeSeq{TacticList{CITP}}
    -> NeSeq{TacticList{CITP}} [ctor ditto] .

  *** init  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
  op init : Seq{TacticList{CITP}} -> Seq{TacticList{CITP}} .
  eq init(STtL TtL .) = STtL .
  eq init(STtL) = STtL [owise] .

  *** size  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
  op size : Seq{TacticList{CITP}} -> Nat .
  eq size(no-tl) = 0 .
  eq size(TtL . STtL) = s size(STtL) .
endfm

*** ----------------------------------------------------------------------------

fmod CITP/PROOF is
  protecting CITP/GOAL .
  protecting CITP/TACTIC .

  var PN : Qid .
  var G : Goal{CITP} .
  var STtL : Seq{TacticList{CITP}} .

  *** Proof{CITP}  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  sorts Proof{CITP} NeProofList{CITP} ProofList{CITP} .
  subsorts Proof{CITP} < NeProofList{CITP} < ProofList{CITP} .
  op proof_of_is_qed : Qid Goal{CITP} Seq{TacticList{CITP}} -> Proof{CITP} .
  op nil : -> ProofList{CITP} [ctor] .
  op __ : ProofList{CITP} ProofList{CITP} -> ProofList{CITP}
    [ctor assoc id: nil format (d ni d)] .
  op __ : NeProofList{CITP} ProofList{CITP} -> NeProofList{CITP} [ctor ditto] .
  op __ : ProofList{CITP} NeProofList{CITP} -> NeProofList{CITP} [ctor ditto] .

  *** name  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
  op name : Proof{CITP} -> Qid .
  eq name(proof PN of G is STtL qed) = PN .

  *** base module  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  op base-module : Proof{CITP} -> Module .
  eq base-module(proof PN of G is STtL qed) = module(G) .

  *** size  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
  op size : Proof{CITP} -> Nat .
  eq size(proof PN of G is STtL qed) = size(STtL) .
endfm

*** ----------------------------------------------------------------------------

view CITP/Proof from TRIV to CITP/PROOF is
  sort Elt to Proof{CITP} .
endv

*** ----------------------------------------------------------------------------

fmod CITP/PROOF-DICT is
  protecting DICTIONARY { Qid, CITP/Proof } *
    (sort KeyValuePair{Qid,CITP/Proof} to PDEntry{CITP},
     sort Dict{Qid,CITP/Proof} to ProofDict{CITP}) .

  var PD : ProofDict{CITP} .
  var P : Proof{CITP} .
  var PN : Qid .

  *** proof-names  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  op proof-names : ProofDict{CITP} -> QidSet .
  eq proof-names(empty) = none .
  eq proof-names((PN : P, PD)) = PN ; proof-names(PD) .

  *** proof-list  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
  op list : ProofDict{CITP} -> ProofList{CITP} .
  eq list(empty) = nil .
  eq list((PN : P, PD)) = P list(PD) .
endfm

********************************************************************************

fmod CITP/DATABASE is
  protecting CITP/MODULE-DICT .
  protecting CITP/GOAL-DICT .
  protecting CITP/PROOF-DICT .

  var  L : CITP .
  var  MD : ModuleDict{CITP} .
  var  GD : GoalDict{CITP} .
  var  PD : ProofDict{CITP} .
  vars MN GN PN : Qid .
  var  M : Module .
  var  G : Goal{CITP} .
  var  P : Proof{CITP} .

  *** DB{CITP}  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
  sort DB{CITP} .
  op DB[_]{_&_&_} : CITP
    ModuleDict{CITP} GoalDict{CITP} ProofDict{CITP} -> DB{CITP} [ctor] .

  *** empty  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  op empty : -> DB{CITP} .
  eq empty = DB[CITP]{empty & empty & empty} .

  *** modules  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  op modules : DB{CITP} -> ModuleDict{CITP} .
  eq modules(DB[L]{MD & GD & PD}) = MD .

  *** goals  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  op goals : DB{CITP} -> GoalDict{CITP} .
  eq goals(DB[L]{MD & GD & PD}) = GD .

  *** proofs  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
  op proofs : DB{CITP} -> ProofDict{CITP} .
  eq proofs(DB[L]{MD & GD & PD}) = PD .

  *** insert module  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  op insert-module : Qid Module DB{CITP} -> DB{CITP} .
  eq insert-module(MN, M, DB[L]{MD & GD & PD})
   = DB[L]{insert(MN, M, MD) & GD & PD} .

  *** module names  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
  op module-names : DB{CITP} -> QidSet .
  eq module-names(DB[L]{MD & GD & PD}) = module-names(MD) .

  *** insert goal  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  op insert-goal : Qid Goal{CITP} DB{CITP} -> DB{CITP} .
  eq insert-goal(GN, G, DB[L]{MD & GD & PD})
   = DB[L]{MD & insert(GN, G, GD) & PD} .

  *** goal names  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
  op goal-names : DB{CITP} -> QidSet .
  eq goal-names(DB[L]{MD & GD & PD}) = goal-names(GD) .

  *** insert proof  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
  op insert-proof : Qid Proof{CITP} DB{CITP} -> DB{CITP} .
  eq insert-proof(PN, P, DB[L]{MD & GD & PD})
   = DB[L]{MD & GD & insert(PN, P, PD)} .

  *** proof names  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  op proof-names : DB{CITP} -> QidSet .
  eq proof-names(DB[L]{MD & GD & PD}) = proof-names(PD) .
endfm

********************************************************************************

fmod CITP/CMD is
  protecting CITP/LID .
  protecting ATERM .

  sort Cmd{CITP} .
  op Cmd[_]{import_module_} : CITP QidList Qid -> Cmd{CITP} [ctor] .
  op Cmd[_]{list`modules} : CITP -> Cmd{CITP} [ctor] .
  op Cmd[_]{show`module_} : CITP Qid -> Cmd{CITP} [ctor] .
  op Cmd[_]{list`goals} : CITP -> Cmd{CITP} [ctor] .
  op Cmd[_]{show`goal_} : CITP Qid -> Cmd{CITP} [ctor] .
  op Cmd[_]{list`proofs} : CITP -> Cmd{CITP} [ctor] .
  op Cmd[_]{show`proof_} : CITP Qid -> Cmd{CITP} [ctor] .
  op Cmd[_]{show`proofs} : CITP -> Cmd{CITP} [ctor] .
  op Cmd[_]{begin`proof_of_} : CITP Qid Qid -> Cmd{CITP} [ctor] .
  op Cmd[_]{qed} : CITP -> Cmd{CITP} [ctor] .
  op Cmd[_]{show`ongoing`proof} : CITP -> Cmd{CITP} [ctor] .
  op Cmd[_]{show`goals} : CITP -> Cmd{CITP} [ctor] .
  op Cmd[_]{show`goals`abridged} : CITP -> Cmd{CITP} [ctor] .
  op Cmd[_]{show`current`goal} : CITP -> Cmd{CITP} [ctor] .
  op Cmd[_]{show`current`goal`abridged} : CITP -> Cmd{CITP} [ctor] .
  op Cmd[_]{show`current`module} : CITP -> Cmd{CITP} [ctor] .
  op Cmd[_]{show`additions} : CITP -> Cmd{CITP} [ctor] .
  op Cmd[_]{rollback} : CITP -> Cmd{CITP} [ctor] .
  op Cmd[_]{reduce`term_} : CITP ATerm -> Cmd{CITP} [ctor] .
  op Cmd[_]{search`path`from_to_} : CITP ATerm ATerm -> Cmd{CITP} [ctor] .
endfm

********************************************************************************

fmod CITP/APPLY is
  protecting CITP/TACTIC .
  protecting CITP/GOAL .
  protecting CITP/PROOF .

  var G : Goal{CITP} .
  var GL : GoalList{CITP} .
  var NGL : NeGoalList{CITP} .
  var SGL : Seq{GoalList{CITP}} .
  var Tt : Tactic{CITP} .
  var FTt : FunTactic{CITP} .
  var TtL : TacticList{CITP} .
  var NTtL : NeTacticList{CITP} .
  var STtL : Seq{TacticList{CITP}} .
  var PN : Qid .

  *** apply  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  op apply : TacticList{CITP} GoalList{CITP} -> GoalList{CITP} [memo] .
  eq apply(Tt NTtL, GL) = apply(NTtL, apply(Tt, GL)) .
  eq apply(FTt, G NGL) = apply(FTt, G) apply(FTt, NGL) .
  eq apply(TtL, GL) = GL [owise] .

  op apply : Seq{TacticList{CITP}} GoalList{CITP} -> GoalList{CITP} [memo] .
  eq apply(TtL . STtL, GL) = apply(STtL, apply(TtL, GL)) .
  eq apply(STtL, GL) = GL [owise] .

  op apply : Seq{TacticList{CITP}} Seq{GoalList{CITP}} -> Seq{GoalList{CITP}}
    [memo] .
  eq apply(TtL . STtL, SGL GL .)
   = apply(STtL, SGL GL . apply(TtL, GL) .) .
  eq apply(STtL, SGL) = SGL [owise] .

  *** eval  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
  op eval : Proof{CITP} -> GoalList{CITP} [memo] .
  eq eval(proof PN of G is STtL qed) = last-list(apply(STtL, G .)) .
endfm

*** ----------------------------------------------------------------------------

fmod CITP/APPLY/SPLIT is
  including CITP/APPLY .

  var  L : CITP .
  vars GN QI : Qid .
  vars GA MA : QidList .
  var  M : Module .
  var  H : FormDeclList{CITP} .
  var  FD : FormDecl{CITP} .
  var  C : NeFormDeclList{CITP} .
  var  N : Nat .

  *** split a goal with multiple conclusions into an equivalent bunch
  *** of multiple goals with one conclusion each
  eq apply(Tactic[L]{split}, goal GN[GA] is H |-{M[MA]} FD C endg)
   = split(goal GN[GA 'split] is H |-{M[MA]} FD C endg, 1) .

  op split : Goal{CITP} Nat -> GoalList{CITP} .
  eq split(goal GN[GA] is H |-{M[MA]} FD C endg, N)
   = split(goal GN[GA] is H |-{M[MA]} FD endg, N)
     split(goal GN[GA] is H |-{M[MA]} C endg, s N) .
  eq split(goal GN[GA QI] is H |-{M[MA]} FD endg, N)
   = goal GN[GA qid(QI '`( qid(N) '`))] is H |-{M[MA]} FD endg .
  eq split(goal GN[GA] is H |-{M[MA]} no-fd endg, N)
   = goal GN[GA] is H |-{M[MA]} no-fd endg .
endfm

*** ----------------------------------------------------------------------------

fmod CITP/APPLY/@CRT is
  including CITP/APPLY .

  var  L : CITP .
  var  TtL : TacticList{CITP} .
  var  G : Goal{CITP} .
  var  GL : GoalList{CITP} .

  *** apply a tactic list to the current goal  - - - - - - - - - - - - - - - - -
  eq apply(Tactic[L]{@crt TtL}, G GL) = apply(TtL, G) GL .
endfm

*** ----------------------------------------------------------------------------

fmod CITP/APPLY/SIMP is
  including CITP/APPLY .

  var  L : CITP .
  vars GL GL' : GoalList{CITP} .
  var  F : Formula{CITP} .
  var  FDL : FormDeclList{CITP} .
  var  AtS : AttrSet .
  var  RP : ResultPair .

  *** apply the goal-simplification tactic  - - - - - - - - - - - - - - - - - --
  ceq apply(Tactic[L]{simp}, GL)
   = downTerm(getTerm(RP), GL)
   if RP := metaReduce(upModule('CITP/GOAL/SIMP, true), upTerm(GL)) .

  op simp : Formula{CITP} -> Formula{CITP} .
  ceq simp(F) = downTerm(getTerm(RP), F)
   if RP := metaReduce(upModule('CITP/GOAL/SIMP, true), upTerm(F)) .
  eq simp(F) = F [owise] .

  op simp : FormDeclList{CITP} -> FormDeclList{CITP} .
  eq simp(no-fd) = no-fd .
  eq simp(fm F [AtS] . FDL) = fm simp(F) [AtS] . simp(FDL) .
endfm

*** ----------------------------------------------------------------------------

fmod CITP/APPLY/REDUCE is
  including CITP/APPLY .

  var  L : CITP .
  var  G : Goal{CITP} .
  vars GN FI : Qid .
  vars GA MA : QidList .
  var  M : Module .
  vars H H' : FormDeclList{CITP} .
  vars C C' NFDL1 NFDL2 : NeFormDeclList{CITP} .
  vars F F1 F2 : Formula{CITP} .
  vars T LHS RHS : Term .
  var  S : Sort .
  var  VS : VariableSet .
  var  RP : ResultPair .
  var  AtS : AttrSet .

  *** apply the term-reduction tactic  - - - - - - - - - - - - - - - - - - - - -
  ceq apply(Tactic[L]{reduce}, goal GN[GA] is H |-{M[MA]} C endg)
   = goal GN[GA 'red] is H' |-{M[MA]} C' endg
   if H' := red(M, H)
      /\ C' := red(M, C)
      /\ H' =/= H or-else C' =/= C .

  *** reduce formula declarations  - - - - - - - - - - - - - - - - - - - - - - -
  op red : Module FormDeclList{CITP} -> FormDeclList{CITP} .
  eq red(M, no-fd) = no-fd .
  eq red(M, fm F [AtS] .) = (fm red(M, F) [AtS] .) .
  eq red(M, NFDL1 NFDL2) = red(M, NFDL1) red(M, NFDL2) .

  *** reduce formulas  - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  op red : Module Formula{CITP} -> Formula{CITP} .
  eq red(M, (true).Formula{CITP}) = true .
  eq red(M, (false).Formula{CITP}) = false .
  eq red(M, T :[L]: S) = red(L, M, T) :[L]: S .
  eq red(M, LHS =[L]= RHS) = red(L, M, LHS) =[L]= red(L, M, RHS) .
  eq red(M, LHS :[L]= RHS) = red(L, M, LHS) :[L]= red(L, M, RHS) .
  eq red(M, LHS =[L]> RHS) = red(L, M, LHS) =[L]> red(L, M, RHS) .
  eq red(M, ~ F) = ~ red(M, F) .
  eq red(M, F1 /\ F2) = red(M, F1) /\ red(M, F2) .
  eq red(M, F1 \/ F2) = red(M, F1) \/ red(M, F2) .
  eq red(M, F1 if F2) = red(M, F1) if red(M, F2) .
  eq red(M, forall {VS} F) = forall {VS} red(M, F) .
  eq red(M, exists {VS} F) = exists {VS} red(M, F) .
  eq red(M, fmvar(L, FI)) = fmvar(L, FI) .

  *** reduce terms  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
  op red : CITP Module Term -> Term .
  ceq red(L, M, T) = getTerm(RP) if RP := metaReduce(M, T) .
  eq red(L, M, T) = T [owise] .
endfm

*** ----------------------------------------------------------------------------

fmod CITP/APPLY/RED is
  including CITP/APPLY .

  var  L : CITP .
  var  G : Goal{CITP} .

  *** apply the goal-reduction tactic  - - - - - - - - - - - - - - - - - - - - -
  eq apply(Tactic[L]{red}, G) = apply(Tactic[L]{reduce} Tactic[L]{simp}, G) .
endfm

*** ----------------------------------------------------------------------------

fmod CITP/APPLY/IMP is
  including CITP/APPLY .

  var  L : CITP .
  var  GN : Qid .
  vars GA MA : QidList .
  var  M : Module .
  var  H : FormDeclList{CITP} .
  vars F1 F2 : Formula{CITP} .
  var  AtS : AttrSet .

  *** apply the implication tactic  - - - - - - - - - - - - - - - - - - - - - --
  ceq apply(Tactic[L]{imp}, goal GN[GA] is H |-{M[MA]} fm F1 if F2 [AtS] . endg)
   = goal GN[GA 'imp] is
       H fm F2 [md-update(metadata-attrs(AtS), "[premise]")] .
     |-{M[MA]}
       fm F1 [md-update(AtS, "[conclusion]")] .
     endg
   if fv(F1 if F2) = none .
endfm

*** ----------------------------------------------------------------------------

fmod CITP/APPLY/CONJ is
  including CITP/APPLY .

  var  L : CITP .
  var  GN : Qid .
  vars GA MA : QidList .
  var  M : Module .
  vars FD FD' : FormDecl{CITP} .
  vars H H' H1 H2 FDL : FormDeclList{CITP} .
  vars C NFD' NFDL1 NFDL2 : NeFormDeclList{CITP} .
  vars F1 F2 : Formula{CITP} .
  var  VS : VariableSet .
  var  AtS : AttrSet .

  *** apply the conjunction tactic  - - - - - - - - - - - - - - - - - - - - - --
  ceq apply(Tactic[L]{conj}, goal GN[GA] is H |-{M[MA]} FD endg)
   = apply(Tactic[L]{split}, goal GN[GA 'conj] is H' |-{M[MA]} NFD' endg)
   if H' := conjuncts(H)
      /\ NFD' := conjuncts(FD)
      /\ H' =/= H or-else NFD' =/= FD .

  op conjuncts : FormDeclList{CITP} -> FormDeclList{CITP} .
  eq conjuncts(fm F1 /\ F2 [AtS] .)
   = conjuncts(fm F1 [md-update(AtS, "[lhs]")] .)
     conjuncts(fm F2 [md-update(AtS, "[rhs]")] .) .
  eq conjuncts(fm forall {VS} F1 /\ F2 [AtS] .)
   = conjuncts(fm forall {VS} F1 [md-update(AtS, "[lhs]")] .)
     conjuncts(fm forall {VS} F2 [md-update(AtS, "[rhs]")] .) .
  eq conjuncts(NFDL1 NFDL2)
   = conjuncts(NFDL1) conjuncts(NFDL2) .
  eq conjuncts(FDL) = FDL [owise] .
endfm

*** ----------------------------------------------------------------------------

fmod CITP/APPLY/DISJ is
  including CITP/APPLY .

  var  L : CITP .
  var  G : Goal{CITP} .
  var  GN : Qid .
  vars GA MA : QidList .
  var  M : Module .
  vars FD FD' : FormDecl{CITP} .
  vars H FDL H1 H2 : FormDeclList{CITP} .
  vars C NFDL NFDL1 NFDL2 : NeFormDeclList{CITP} .
  vars F1 F2 : Formula{CITP} .
  var  AtS : AttrSet .
  var  SR : String .
  var  N : Nat .

  *** apply the discjunction tactic  - - - - - - - - - - - - - - - - - - - - - -
  ceq apply(Tactic[L]{disj N}, goal GN[GA] is H |-{M[MA]} FD endg)
   = goal GN[GA qid('disj '`( qid(N) '`))] is H |-{M[MA]} FD' endg
   if FD' := md-update(split-disj(FD)[N], "." + string(N, 10)) .

  ceq apply(Tactic[L]{disj SR}, goal GN[GA] is H |-{M[MA]} C endg)
   = disj(NFDL, 1, goal GN[GA qid('disj '`( qid(SR) '`))] is H |-{M[MA]} C endg)
   if FD := H[SR]
      /\ NFDL := split-disj(FD) .

  op disj : FormDeclList{CITP} Nat Goal{CITP} -> GoalList{CITP} .
  eq disj(no-fd, N, G) = no-goal .
  eq disj(FD FDL, N, goal GN[GA] is H |-{M[MA]} C endg)
   = if occurs(FD, H) then no-goal
     else goal GN[GA] is
            H md-update(FD, "." + string(N, 10))
          |-{M[MA]}
            C
          endg fi
     disj(FDL, s N, goal GN[GA] is H |-{M[MA]} C endg) .

  op split-disj : FormDecl{CITP} -> NeFormDeclList{CITP} .
  eq split-disj(fm F1 \/ F2 [AtS] .)
   = split-disj(fm F1 [AtS] .) split-disj(fm F2 [AtS] .) .
  eq split-disj(FD) = FD [owise] .
endfm

*** ----------------------------------------------------------------------------

fmod CITP/APPLY/TC is
  including CITP/APPLY .

  var  L : CITP .
  var  GN : Qid .
  vars GA MA : QidList .
  vars M M' : Module .
  var  H : FormDeclList{CITP} .
  var  FD : FormDecl{CITP} .
  var  F : Formula{CITP} .
  var  VS : VariableSet .
  var  SB : Substitution .
  var  AtS : AttrSet .

  *** apply the theorem-of-constants  - - - - - - - - - - - - - - - - - - - - --
 ceq apply(Tactic[L]{tc}, goal GN[GA] is H |-{M[MA]} FD endg) =
     goal GN[GA 'tc] is
       H
     |-{M'[MA qid('`[ intersperse(';, list-terms(terms(SB), M')) '`])]}
       fm F << SB [md-update(AtS, SB, M')] .
     endg
  if fm F [AtS] . := strip(FD)
     /\ VS := fv(F)
     /\ SB := v2s(VS, s getLB(getOps(M)))
     /\ M' := addSB(SB, M) .
endfm

*** ----------------------------------------------------------------------------

fmod CITP/APPLY/SK is
  including CITP/APPLY .

  var  L : CITP .
  var  GN : Qid .
  vars GA MA : QidList .
  vars M M' : Module .
  vars H H1 H2 : FormDeclList{CITP} .
  var  C : NeFormDeclList{CITP} .
  var  F : Formula{CITP} .
  var  NVS : NeVariableSet .
  var  SB : Substitution .
  var  AtS : AttrSet .

  *** apply Skolemization  - - - - - - - - - - - - - - - - - - - - - - - - - - -
  ceq apply(Tactic[L]{sk}, goal GN[GA] is H |-{M[MA]} C endg)
   = apply(Tactic[L]{sk},
       goal GN[GA 'sk] is
         H1 fm F << SB [md-update(AtS, SB, M')] . H2
       |-{M'[MA qid('`[ intersperse(';, list-terms(terms(SB), M')) '`])]}
         C
       endg)
   if H1 fm exists {NVS} F [AtS] . H2 := H
      /\ SB := v2s(NVS, s getLB(getOps(M)))
      /\ M' := addSB(SB, M) .
endfm

*** ----------------------------------------------------------------------------

fmod CITP/APPLY/CA is
  including  CITP/APPLY/REDUCE .
  including  CITP/APPLY/SIMP .
  protecting CITP/BRIDGE/CA .

  var  L : CITP .
  vars G G' : Goal{CITP} .
  var  NGL : NeGoalList{CITP} .
  vars GN QI : Qid .
  vars GA MA : QidList .
  vars F F' F1 F2 : Formula{CITP} .
  var  FD : FormDecl{CITP} .
  vars H H' C C' FDL FDL1 FDL2 : FormDeclList{CITP} .
  vars C1 C2 NFDL1 NFDL2 : NeFormDeclList{CITP} .
  vars LHS RHS T : Term .
  var  GT : GroundTerm .
  var  TL : TermList .
  var  GTL : GroundTermList .
  var  S : Sort .
  var  E : Equation .
  var  ES : EquationSet .
  var  MB : MembAx .
  var  MS : MembAxSet .
  var  R : Rule .
  var  RS : RuleSet .
  vars M M' : Module .
  var  VS : VariableSet .
  var  NVS : NeVariableSet .
  var  AtS : AttrSet .
  var  MP : [MatchPair] .
  var  SB : Substitution .
  var  SR : String .
  var  N : Nat .

  *** apply the case analysis tactics  - - - - - - - - - - - - - - - - - - - - -
  ceq apply(Tactic[L]{ca}, goal GN[GA] is H |-{M[MA]} FD endg) = NGL
   if NGL := ca(goal GN[GA 'ca] is H |-{M[MA]} FD endg, getGT(FD))
      /\ size(NGL) > 1 .
  ceq apply(Tactic[L]{ca-rev}, goal GN[GA] is H |-{M[MA]} FD endg) = NGL
   if NGL := ca(goal GN[GA 'ca-rev] is H |-{M[MA]} FD endg, rev(getGT(FD)))
      /\ size(NGL) > 1 .

  op ca : Goal{CITP} GroundTermList ~> GoalList{CITP} .
  eq ca(G, empty) = G .
  eq ca(goal GN[GA] is H |-{M[MA]} FD endg, (GT, GTL))
   = if match?(M, getCA(CITP, M), GT)
     then split(goal GN[GA] is H |-{M[MA]} FD endg,
                getCA(CITP, M), 0, GT, getCA(CITP, M))
     else ca(goal GN[GA] is H |-{M[MA]} FD endg, GTL) fi .

  *** get equations for case analysis  - - - - - - - - - - - - - - - - - - - - -
  op getCA : CITP EquationSet -> FormDeclList{CITP} .
  eq getCA(L, (none).EquationSet) = no-fd .
  eq getCA(L, E ES)
   = if CA?(E) then eq2fm(L, E) else no-fd fi getCA(L, ES) .

  op getCA : CITP MembAxSet -> FormDeclList{CITP} .
  eq getCA(L, (none).MembAxSet) = no-fd .
  eq getCA(L, MB MS)
   = if CA?(MB) then mb2fm(L, MB) else no-fd fi getCA(L, MS) .

  op getCA : CITP RuleSet -> FormDeclList{CITP} .
  eq getCA(L, (none).RuleSet) = no-fd .
  eq getCA(L, R RS)
   = if CA?(R) then rl2fm(L, R) else no-fd fi getCA(L, RS) .

  op getCA : CITP Module -> FormDeclList{CITP} .
  eq getCA(L, M) = getCA(L, getEqs(M)) getCA(L, getMbs(M)) getCA(L, getRls(M)) .

  *** validate substitution  - - - - - - - - - - - - - - - - - - - - - - - - - -
  op validate : Module FormDeclList{CITP} Term -> Bool .
  eq validate(M, no-fd, T) = true .
  eq validate(M, fm (LHS =[L]= RHS) if F [AtS] . FDL, T)
   = validate(M, LHS, T) and-then validate(M, FDL, T) .
  eq validate(M, fm (LHS :[L]: S) if F [AtS] . FDL, T)
   = validate(M, LHS, T) and-then validate(M, FDL, T) .
  eq validate(M, fm (LHS =[L]> RHS) if F [AtS] . FDL, T)
   = validate(M, LHS, T) and-then validate(M, FDL, T) .
  eq validate(M, FD FDL, T) = false [owise] .

  *** match?  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
  op match? : Module FormDeclList{CITP} GroundTerm -> Bool .
  eq match?(M, no-fd, GT)= false .
  ceq match?(M, fm (LHS =[L]= RHS) if F [AtS] . FDL, GT) = true
   if metaXmatch(M, LHS, GT, nil, 0, unbounded, 0) : MatchPair .
  ceq match?(M, fm (T :[L]: S) if F [AtS] . FDL, GT) = true
   if metaXmatch(M, T, GT, nil, 0, unbounded, 0) : MatchPair .
  ceq match?(M, fm (LHS =[L]> RHS) if F [AtS] . FDL, GT) = true
   if metaXmatch(M, LHS, GT, nil, 0, unbounded, 0) : MatchPair .
  eq match?(M, FD FDL, GT) = match?(M, FDL, GT) [owise] .

  *** split  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  op split : Goal{CITP} FormDeclList{CITP} Nat GroundTerm FormDeclList{CITP}
    ~> GoalList{CITP} .
  eq split(G, no-fd, N, GT, FDL2) = G .
  ceq split(G, NFDL1, N, GT, NFDL2)
   = if MP :: MatchPair
     then if validate(M, NFDL2, T << getSubstitution(MP))
       then split-h(G, NFDL1, N, GT, NFDL2,
                    getFD(NFDL1, T) << getSubstitution(MP))
       else split(G, NFDL1, s N, GT, NFDL2) fi
     else split(G, rmFD(NFDL1, T), 0, GT, NFDL2) fi
   if goal GN[GA] is H |-{M[MA]} FD endg := G
      /\ T, TL := getTM(NFDL1)
      /\ MP := metaXmatch(M, T, GT, nil, 0, unbounded, N) .

  op split-h : Goal{CITP} NeFormDeclList{CITP} Nat GroundTerm
    NeFormDeclList{CITP} FormDeclList{CITP} ~> GoalList{CITP} .
  eq split-h(G, NFDL1, N, GT, NFDL2, no-fd) = no-goal .
  ceq split-h(G, NFDL1, N, GT, NFDL2, (fm F1 if F2 [AtS] .) FDL1)
   = split(G', NFDL1, s N, GT, NFDL2) split-h(G, NFDL1, N, GT, NFDL2, FDL1)
   if goal GN[GA QI] is H |-{M[MA]} FD endg := G
      /\ M' := addCD(F2, M)
      /\ G' := goal GN[GA qid(QI ': qid(CA-md(AtS)))] is
               H |-{M'[MA qid('`[ 'ca: qid(CA-md(AtS)) '`])]} FD endg .

  *** addCD  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  op addCD : Formula{CITP} Module -> Module .
  ceq addCD(F, M) = addFM(F', M')
   if VS := fv(F)
      /\ N := getLB(getOps(M))
      /\ SB := v2s(VS, s N)
      /\ F1 := red(M, F)
      /\ F' := simp(F1 << SB)
      /\ M' := addSB(SB, M) .

  *** addFM  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  op addFM : Formula{CITP} Module ~> Module .
  ceq addFM(LHS =[L]= RHS, M) = addEQ(eq LHS = RHS [metadata(SR)] ., M)
   if N := getLB(getEqs(M)) /\ SR := string(s N, 10) .
  ceq addFM(LHS :[L]= RHS, M) = addEQ(eq RHS = LHS [metadata(SR)] ., M)
   if N := getLB(getEqs(M)) /\ SR := string(s N, 10) .
  ceq addFM(T :[L]: S, M) = addMB(mb T : S [metadata(SR)] ., M)
   if N := getLB(getMbs(M)) /\ SR := string(s N, 10) .
  ceq addFM(LHS =[L]> RHS, M) = addRL(rl LHS => RHS [metadata(SR)] ., M)
   if N := getLB(getRls(M)) /\ SR := string(s N, 10) .
  eq addFM(F1 /\ F2, M) = addFM(F2, addFM(F1, M)) .
  ceq addFM(F1 if F2, M) = addEQ(E, M)
   if N := getLB(getEqs(M)) /\ E  := addLB(s N, fm2eq(fm F1 if F2 [none] .)) .
  ceq addFM(F1 if F2, M) = addMB(MB, M)
   if N := getLB(getMbs(M)) /\ MB := addLB(s N, fm2mb(fm F1 if F2 [none] .)) .
  ceq addFM(F1 if F2, M) = addRL(R, M)
   if N := getLB(getRls(M)) /\ R  := addLB(s N, fm2rl(fm F1 if F2 [none] .)) .
  eq addFM(forall {NVS} F, M) = addFM(F, M) .
  ceq addFM(exists {NVS} F, M) = addFM(F, addSB(SB, M))
   if fv(exists {NVS} F) = (none).VariableSet
      /\ N := getLB(getOps(M)) /\ SB := v2s(NVS, s N) .
  eq addFM(F,M) = M [owise] .
endfm

*** ----------------------------------------------------------------------------

fmod CITP/APPLY/CS is
  including CITP/APPLY .

  var  CT : Constant .
  var  Q : Qid .
  vars SB SB1 SB2 : Substitution .
  vars FDL FDL1 FDL2 : FormDeclList{CITP} .
  var  NFDL : NeFormDeclList{CITP} .
  var  M : Module .
  vars TP TP1 TP2 TP3 TP4 TP5 : Type .
  vars V V1 V2 V3 W1 W2 : Variable .
  var  VS : VariableSet .
  vars T T1 T2 T3 T4 T5 : Term .
  vars GT GT1 GT2 : GroundTerm .
  var  GTL : GroundTermList .
  var  TL : TermList .
  var  NTL : NeTermList .
  var  NGTL : NeGroundTermList .
  var  AS : AttrSet .
  vars F F1 F2 F3 F4 F5 : Formula{CITP} .
  var  G : Goal{CITP} .
  vars NGL NGL1 NGL2 : NeGoalList{CITP} .
  ---
  var  L : CITP .
  var  GN : Qid .
  vars GA MA : QidList .
  var  H : FormDeclList{CITP} .
  var  C : NeFormDeclList{CITP} .

  *** apply the cs tactic  - - - - - - - - - - - - - - - - - - - - - -
  eq apply(Tactic[L]{cs}, goal GN[GA] is H |-{M[MA]} C endg)
   = cs(goal GN[GA] is H |-{M[MA]} C endg) .
  --- --- ---
  op isTuple : Qid -> Bool .
  eq isTuple(Q) = false [owise].
  eq isTuple('`(_`,_`)) = true .
  eq isTuple('`[_`,_`]) = true .
  eq isTuple('`{_`,_`}) = true .
  eq isTuple('`(_`,_`,_`)) = true .
  eq isTuple('`{_`,_`,_`}) = true .
  eq isTuple('`[_`,_`,_`]) = true .
  eq isTuple('`(_`,_`,_`,_`)) = true .
  eq isTuple('`{_`,_`,_`,_`}) = true .
  eq isTuple('`[_`,_`,_`,_`]) = true .
  --- --- ---
  op makeFM : TermList GroundTermList -> Formula{CITP} .
  eq makeFM((empty).TermList,GTL)= true .
  eq makeFM(TL,(empty).GroundTermList) = true .
  eq makeFM((T,TL),(GT,GTL)) = (T :[CITP]= GT) /\ makeFM(TL,GTL).
  --- --- ---
  op split-tuple : Module Formula{CITP} -> Formula{CITP} .
  eq split-tuple(M,F) = F [owise].
  ---
  ceq split-tuple(M,Q[NTL] :[CITP]= Q[NGTL]) = makeFM(NTL,NGTL)
   if len(NTL) = len(NGTL) /\ isTuple(Q) .
  eq split-tuple(M,~ F) = ~ split-tuple(M,F).
  eq split-tuple(M,F1 /\ F2) = split-tuple(M,F1) /\ split-tuple(M,F2).
  eq split-tuple(M,F1 \/ F2) = split-tuple(M,F1) \/ split-tuple(M,F2).
  eq split-tuple(M,F1 if F2) = split-tuple(M,F1) if split-tuple(M,F2).
  eq split-tuple(M,forall {VS} F) = forall {VS} split-tuple(M,F).
  eq split-tuple(M,exists {VS} F) = exists {VS} split-tuple(M,F).
  --- --- ---
  op split-tuple : Module FormDeclList{CITP} -> FormDeclList{CITP} .
  eq split-tuple(M,no-fd) = no-fd .
  eq split-tuple(M,fm F[AS]. FDL)
   = fm split-tuple(M,F) [AS]. split-tuple(M,FDL).
  --- --- ---
  op split-tuple : GoalList{CITP} -> GoalList{CITP} .
  eq split-tuple(no-goal) = no-goal .
  eq split-tuple(goal GN[GA] is FDL |-{M[MA]} no-fd endg)= no-goal .
  eq split-tuple(goal GN[GA] is FDL |-{M[MA]} NFDL endg)
   = goal GN[GA] is FDL |-{M[MA]} split-tuple(M,NFDL) endg .
  eq split-tuple(NGL1 NGL2) = split-tuple(NGL1) split-tuple(NGL2).
  --- --- ---
  op cs : Goal{CITP} -> GoalList{CITP}.
  eq cs(G) = G [owise].
  ---
  --- --------------------------------------------------------------------------
  --- 1) V1,T,V2 := GTL ---
  --- --------------------------------------------------------------------------
  *** a ***
  ceq cs(goal GN[GA] is FDL |-{M[MA]} fm F if F1 /\ Q[V1,T,V2] :[L]= Q[GT,NGTL] /\ F2 [AS]. endg)
   = split-tuple(goal GN[GA] is FDL |-{M[MA]} fm F << V2 <- Q[V2,NGTL] if F1 << V2 <- Q[V2,NGTL]/\ Q[V1,T,V2] :[L]= GT     /\ F2 << V2 <- Q[V2,NGTL][AS]. endg)
     cs(goal GN[GA] is FDL |-{M[MA]} fm F << V1 <- Q[GT,V1]   if F1 << V1 <- Q[GT,V1]  /\ Q[V1,T,V2] :[L]= Q[NGTL]/\ F2 << V1 <- Q[GT,V1] [AS]. endg)
   if TP := leastSort(M,T)/\ TP1 := getType(V1)/\ TP2 := getType(V2)/\
      TP1 = TP2 /\ TP =/= TP1 /\ sortLeq(M,TP,TP1) /\
      isCtr(M,TP1,Q)/\ isAssoc(M,TP1,Q) /\ leastSort(M,GT)= TP1 .
  ---
  ceq cs(goal GN[GA] is FDL |-{M[MA]} fm F if Q[V1,T,V2] :[L]= Q[GT,NGTL] /\ F2 [AS]. endg)
   = split-tuple(goal GN[GA] is FDL |-{M[MA]} fm F << V2 <- Q[V2,NGTL]if Q[V1,T,V2]:[L]= GT      /\ F2 << V2 <- Q[V2,NGTL][AS]. endg)
     cs(goal GN[GA] is FDL |-{M[MA]} fm F << V1 <- Q[GT,V1]  if Q[V1,T,V2]:[L]= Q[NGTL]/\ F2 << V1 <- Q[GT,V1]  [AS].  endg)
   if TP := leastSort(M,T)/\ TP1 := getType(V1)/\ TP2 := getType(V2)/\
      TP1 = TP2 /\ TP =/= TP1 /\ sortLeq(M,TP,TP1)/\
      isCtr(M,TP1,Q)/\ isAssoc(M,TP1,Q) /\ leastSort(M,GT)= TP1 .
  ---
  ceq cs(goal GN[GA] is FDL |-{M[MA]} fm F if F1 /\ Q[V1,T,V2] :[L]= Q[GT,NGTL] [AS]. endg)
   = split-tuple(goal GN[GA] is FDL |-{M[MA]} fm F << V2 <- Q[V2,NGTL]if F1 << V2 <- Q[V2,NGTL]/\ Q[V1,T,V2]:[L]= GT     [AS]. endg)
     cs(goal GN[GA] is FDL |-{M[MA]} fm F << V1 <- Q[GT,V1]  if F1 << V1 <- Q[GT,V1] /\ Q[V1,T,V2] :[L]= Q[NGTL][AS]. endg)
   if TP := leastSort(M,T)/\ TP1 := getType(V1)/\ TP2 := getType(V2)/\
      TP1 = TP2 /\ TP =/= TP1 /\ sortLeq(M,TP,TP1) /\
      isCtr(M,TP1,Q)/\ isAssoc(M,TP1,Q) /\ leastSort(M,GT)= TP1 .
  ---
  ceq cs(goal GN[GA] is FDL |-{M[MA]} fm F if Q[V1,T,V2] :[L]= Q[GT,NGTL] [AS]. endg)
   = split-tuple(goal GN[GA] is FDL |-{M[MA]} fm F << V2 <- Q[V2,NGTL] if Q[V1,T,V2] :[L]= GT      [AS]. endg)
     cs(goal GN[GA] is FDL |-{M[MA]} fm F <<(V1 <- Q[GT,V1])  if Q[V1,T,V2] :[L]= Q[NGTL][AS]. endg)
   if TP := leastSort(M,T)/\ TP1 := getType(V1)/\ TP2 := getType(V2)/\
      TP1 = TP2 /\ TP =/= TP1 /\ sortLeq(M,TP,TP1)/\
      isCtr(M,TP1,Q)/\ isAssoc(M,TP1,Q) /\ leastSort(M,GT)= TP1 .
  *** b ***
  ceq cs(goal GN[GA] is FDL |-{M[MA]}fm F if F1 /\ Q[V1,T,V2] :[L]= Q[GT,NGTL] /\ F2 [AS]. endg)
   = split-tuple(goal GN[GA] is FDL |-{M[MA]}fm F << V1 <- CT ; V2 <- Q[NGTL]if F1 << V1 <- CT ; V2 <- Q[NGTL]/\ T :[L]= GT /\ F2 << V1 <- CT ; V2 <- Q[NGTL][AS]. endg)
     cs(goal GN[GA] is FDL |-{M[MA]}fm F << V1 <- Q[GT,V1] if F1 << V1 <- Q[GT,V1] /\ Q[V1,T,V2] :[L]= Q[NGTL] /\ F2 << V1 <- Q[GT,V1] [AS]. endg)
   if TP := leastSort(M,T)/\ TP1 := getType(V1)/\ TP2 := getType(V2)/\
      TP1 = TP2 /\ TP =/= TP1 /\ sortLeq(M,TP,TP1) /\
      isCtr(M,TP1,Q)/\ isAssoc(M,TP1,Q)/\ CT := getID(M,TP1,Q)/\ leastSort(M,GT)= TP .
  ---
  ceq cs(goal GN[GA] is FDL |-{M[MA]}fm F if  Q[V1,T,V2] :[L]= Q[GT,NGTL] /\ F2 [AS]. endg)
   = split-tuple(goal GN[GA] is FDL |-{M[MA]}fm F <<(V1 <- CT ; V2 <- Q[NGTL])if T :[L]= GT /\ F2 <<(V1 <- CT ; V2 <- Q[NGTL])[AS]. endg)
     cs(goal GN[GA] is FDL |-{M[MA]}fm F <<(V1 <- Q[GT,V1])  if Q[V1,T,V2] :[L]= Q[NGTL]/\ F2 <<(V1 <- Q[GT,V1])[AS]. endg)
   if TP := leastSort(M,T)/\ TP1 := getType(V1)/\ TP2 := getType(V2)/\
      TP1 = TP2 /\ TP =/= TP1 /\ sortLeq(M,TP,TP1) /\
      isCtr(M,TP1,Q)/\ isAssoc(M,TP1,Q)/\ CT := getID(M,TP1,Q)/\ leastSort(M,GT)= TP .
  ---
  ceq cs(goal GN[GA] is FDL |-{M[MA]}fm F if F1 /\ Q[V1,T,V2] :[L]= Q[GT,NGTL] [AS]. endg)
   = split-tuple(goal GN[GA] is FDL |-{M[MA]}fm F << V1 <- CT ; V2 <- Q[NGTL] if F1 << V1 <- CT ; V2 <- Q[NGTL] /\ T :[L]= GT [AS]. endg)
     cs(goal GN[GA] is FDL |-{M[MA]}fm F << V1 <- Q[GT,V1] if F1 << V1 <- Q[GT,V1] /\ Q[V1,T,V2] :[L]= Q[NGTL][AS]. endg)
   if TP := leastSort(M,T)/\ TP1 := getType(V1)/\ TP2 := getType(V2)/\
      TP1 = TP2 /\ TP =/= TP1 /\ sortLeq(M,TP,TP1) /\
      isCtr(M,TP1,Q)/\ isAssoc(M,TP1,Q)/\ CT := getID(M,TP1,Q) /\ leastSort(M,GT)= TP .
  ---
  ceq cs(goal GN[GA] is FDL |-{M[MA]}fm F if Q[V1,T,V2] :[L]= Q[GT,NGTL] [AS]. endg)
   = split-tuple(goal GN[GA] is FDL |-{M[MA]}fm F << V1 <- CT ; V2 <- Q[NGTL] if T :[L]= GT [AS]. endg)
     cs(goal GN[GA] is FDL |-{M[MA]}fm F << V1 <- Q[GT,V1] if Q[V1,T,V2] :[L]= Q[NGTL][AS]. endg)
   if TP := leastSort(M,T)/\ TP1 := getType(V1)/\ TP2 := getType(V2)/\
      TP1 = TP2 /\ TP =/= TP1 /\ sortLeq(M,TP,TP1) /\
      isCtr(M,TP1,Q)/\ isAssoc(M,TP1,Q)/\ CT := getID(M,TP1,Q)/\ leastSort(M,GT)= TP .
  *** c ***
  ceq cs(goal GN[GA] is FDL |-{M[MA]}   fm F if F1 /\ Q[V1,T,V2]:[L]= Q[GT] /\ F2 [AS]. endg)
   = split-tuple(goal GN[GA] is FDL |-{M[MA]} fm F if F1 /\ Q[V1,T,V2]:[L]=   GT  /\ F2 [AS]. endg)
   if TP := leastSort(M,T)/\ TP1 := getType(V1)/\ TP2 := getType(V2)/\
      TP1 = TP2 /\ TP =/= TP1 /\ sortLeq(M,TP,TP1) /\
      isCtr(M,TP1,Q)/\ isAssoc(M,TP1,Q)/\ leastSort(M,GT)= TP1 .
  ---
  ceq cs(goal GN[GA] is FDL |-{M[MA]}fm F if  Q[V1,T,V2]:[L]= Q[GT] /\ F2 [AS]. endg)
   = split-tuple(goal GN[GA] is FDL |-{M[MA]}fm F if  Q[V1,T,V2]:[L]=   GT  /\ F2 [AS]. endg)
   if TP := leastSort(M,T)/\ TP1 := getType(V1)/\ TP2 := getType(V2)/\
      TP1 = TP2 /\ TP =/= TP1 /\ sortLeq(M,TP,TP1) /\
      isCtr(M,TP1,Q)/\ isAssoc(M,TP1,Q)/\ leastSort(M,GT)= TP1 .
  ---
  ceq cs(goal GN[GA] is FDL |-{M[MA]}fm F if  F1 /\ Q[V1,T,V2]:[L]= Q[GT] [AS]. endg)
   = split-tuple(goal GN[GA] is FDL |-{M[MA]}fm F if  F1 /\ Q[V1,T,V2]:[L]=   GT  [AS]. endg)
   if TP := leastSort(M,T)/\ TP1 := getType(V1)/\ TP2 := getType(V2)/\
      TP1 = TP2 /\ TP =/= TP1 /\ sortLeq(M,TP,TP1) /\
      isCtr(M,TP1,Q)/\ isAssoc(M,TP1,Q)/\ leastSort(M,GT)= TP1 .
  ---
  ceq cs(goal GN[GA] is FDL |-{M[MA]}fm F if Q[V1,T,V2]:[L]= Q[GT] [AS]. endg)
   = split-tuple(goal GN[GA] is FDL |-{M[MA]}fm F if Q[V1,T,V2]:[L]=   GT  [AS]. endg)
   if TP := leastSort(M,T)/\ TP1 := getType(V1)/\ TP2 := getType(V2)/\
      TP1 = TP2 /\ TP =/= TP1 /\ sortLeq(M,TP,TP1) /\
      isCtr(M,TP1,Q)/\ isAssoc(M,TP1,Q)/\ leastSort(M,GT)= TP1 .
  --- d ---
  ceq cs(goal GN[GA] is FDL |-{M[MA]}fm F if F1 /\ Q[V1,T,V2] :[L]= Q[GT] /\ F2 [AS]. endg)
   = split-tuple(goal GN[GA] is FDL |-{M[MA]}fm F <<(V1 <- CT ; V2 <- CT) if F1 << V1 <- CT ; V2 <- CT /\ T :[L]= GT /\ F2 << V1 <- CT ; V2 <- CT [AS]. endg)
   if TP := leastSort(M,T)/\ TP1 := getType(V1)/\ TP2 := getType(V2)/\
      TP1 = TP2 /\ TP =/= TP1 /\ sortLeq(M,TP,TP1) /\
      isCtr(M,TP1,Q)/\ isAssoc(M,TP1,Q)/\ CT := getID(M,TP1,Q)/\ leastSort(M,GT)= TP .
  ---
  ceq cs(goal GN[GA] is FDL |-{M[MA]}fm F if Q[V1,T,V2] :[L]= Q[GT] /\ F2 [AS]. endg)
   = split-tuple(goal GN[GA] is FDL |-{M[MA]}fm F <<(V1 <- CT ; V2 <- CT) if T :[L]= GT /\ F2 <<(V1 <- CT ; V2 <- CT)[AS]. endg)
   if TP := leastSort(M,T)/\ TP1 := getType(V1)/\ TP2 := getType(V2)/\
      TP1 = TP2 /\ TP =/= TP1 /\ sortLeq(M,TP,TP1)/\
      isCtr(M,TP1,Q)/\ isAssoc(M,TP1,Q)/\ CT := getID(M,TP1,Q)/\ leastSort(M,GT)= TP .
  ---
  ceq cs(goal GN[GA] is FDL |-{M[MA]}fm F if F1 /\ Q[V1,T,V2] :[L]= Q[GT] [AS]. endg)
   = split-tuple(goal GN[GA] is FDL |-{M[MA]}fm F <<(V1 <- CT ; V2 <- CT) if F1 << V1 <- CT ; V2 <- CT /\ T :[L]= GT [AS]. endg)
   if TP := leastSort(M,T)/\ TP1 := getType(V1)/\ TP2 := getType(V2)/\
      TP1 = TP2 /\ TP =/= TP1 /\ sortLeq(M,TP,TP1)/\
      isCtr(M,TP1,Q)/\ isAssoc(M,TP1,Q)/\ CT := getID(M,TP1,Q)/\ leastSort(M,GT)= TP .
  ---
  ceq cs(goal GN[GA] is FDL |-{M[MA]}fm F if Q[V1,T,V2] :[L]= Q[GT] [AS]. endg)
   = split-tuple(goal GN[GA] is FDL |-{M[MA]}fm F <<(V1 <- CT ; V2 <- CT) if T :[L]= GT [AS]. endg)
   if TP := leastSort(M,T)/\ TP1 := getType(V1)/\ TP2 := getType(V2)/\
      TP1 = TP2 /\ TP =/= TP1 /\ sortLeq(M,TP,TP1)/\
      isCtr(M,TP1,Q)/\ isAssoc(M,TP1,Q)/\ CT := getID(M,TP1,Q)/\ leastSort(M,GT)= TP .
  --- --------------------------------------------------------------------------
  --- 2) V1,T1,V2,T2,V3 := GTL ---
  --- --------------------------------------------------------------------------
  *** a ***
  ceq cs(goal GN[GA] is FDL |-{M[MA]}fm F if F1 /\ Q[V1,T1,V2,T2,V3] :[L]= Q[GT,NGTL] /\ F2 [AS]. endg)
   = split-tuple(goal GN[GA] is FDL |-{M[MA]}fm F << V3 <- Q[V3,NGTL]if F1 << V3 <- Q[V3,NGTL]/\ Q[V1,T1,V2,T2,V3] :[L]= GT /\ F2 << V3 <- Q[V3,NGTL][AS]. endg)
     cs(goal GN[GA] is FDL |-{M[MA]}fm F << V1 <- Q[GT,V1]  if F1 << V1 <- Q[GT,V1]  /\ Q[V1,T1,V2,T2,V3] :[L]= Q[NGTL] /\ F2 << V1 <- Q[GT,V1][AS]. endg)
     cs(goal GN[GA] is FDL |-{M[MA]}fm F << V2 <- Q[W1,W2]  if F1 << V2 <- Q[W1,W2]  /\ Q[V1,T1,W1] :[L]= GT /\ Q[W2,T2,V3] :[L]= Q[NGTL] /\ F2 << V2 <- Q[W1,W2][AS]. endg)
   if getType(V1) = getType(V2) /\
      getType(V2) = leastSort(M,V3) /\
      leastSort(M,T1) = leastSort(M,T2) /\
      sortLeq(M,leastSort(M,T1),getType(V1)) /\
      leastSort(M,T1) =/= getType(V1) /\
      leastSort(M,GT) = getType(V1) /\
      W1 := qid(string(getName(V2)) + "#1:" + string(getType(V2))) /\
      W2 := qid(string(getName(V2)) + "#2:" + string(getType(V2))) /\
      isCtr(M,getType(V1),Q)/\ isAssoc(M,getType(V1),Q) .
  ---
  ceq cs(goal GN[GA] is FDL |-{M[MA]}fm F if Q[V1,T1,V2,T2,V3] :[L]= Q[GT,NGTL] /\ F2 [AS]. endg)
   = split-tuple(goal GN[GA] is FDL |-{M[MA]}fm F << V3 <- Q[V3,NGTL] if Q[V1,T1,V2,T2,V3] :[L]= GT      /\ F2 << V3 <- Q[V3,NGTL] [AS]. endg)
     cs(goal GN[GA] is FDL |-{M[MA]}fm F << V1 <- Q[GT,V1]   if Q[V1,T1,V2,T2,V3] :[L]= Q[NGTL] /\ F2 << V1 <- Q[GT,V1] [AS]. endg)
     cs(goal GN[GA] is FDL |-{M[MA]}fm F << V2 <- Q[W1,W2]   if Q[V1,T1,W1] :[L]= GT /\ Q[W2,T2,V3] :[L]= Q[NGTL] /\ F2 << V2 <- Q[W1,W2][AS]. endg)
   if getType(V1) = getType(V2) /\
      getType(V2) = leastSort(M,V3) /\
      leastSort(M,T1) = leastSort(M,T2) /\
      sortLeq(M,leastSort(M,T1),getType(V1)) /\
      leastSort(M,T1) =/= getType(V1) /\
      leastSort(M,GT) = getType(V1) /\
      W1 := qid(string(getName(V2)) + "#1:" + string(getType(V2))) /\
      W2 := qid(string(getName(V2)) + "#2:" + string(getType(V2))) /\
      isCtr(M,getType(V1),Q)/\ isAssoc(M,getType(V1),Q) .
  ---
  ceq cs(goal GN[GA] is FDL |-{M[MA]}fm F if F1 /\ Q[V1,T1,V2,T2,V3] :[L]= Q[GT,NGTL] [AS]. endg)
   = split-tuple(goal GN[GA] is FDL |-{M[MA]}fm F <<(V3 <- Q[V3,NGTL])if F1 << V3 <- Q[V3,NGTL]/\ Q[V1,T1,V2,T2,V3] :[L]= GT [AS]. endg)
     cs(goal GN[GA] is FDL |-{M[MA]}fm F <<(V1 <- Q[GT,V1])  if F1 << V1 <- Q[GT,V1]  /\ Q[V1,T1,V2,T2,V3] :[L]= Q[NGTL] [AS]. endg)
     cs(goal GN[GA] is FDL |-{M[MA]}fm F <<(V2 <- Q[W1,W2])  if F1 << V2 <- Q[W1,W2]  /\ Q[W2,T2,V3] :[L]= Q[NGTL] /\ Q[V1,T1,W1] :[L]= GT[AS]. endg)
   if getType(V1) = getType(V2) /\
      getType(V2) = leastSort(M,V3) /\
      leastSort(M,T1) = leastSort(M,T2) /\
      sortLeq(M,leastSort(M,T1),getType(V1)) /\
      leastSort(M,T1) =/= getType(V1) /\
      leastSort(M,GT) = getType(V1) /\
      W1 := qid(string(getName(V2)) + "#1:" + string(getType(V2))) /\
      W2 := qid(string(getName(V2)) + "#2:" + string(getType(V2)))/\
      isCtr(M,getType(V1),Q)/\ isAssoc(M,getType(V1),Q) .
  ---
  ceq cs(goal GN[GA] is FDL |-{M[MA]}fm F if Q[V1,T1,V2,T2,V3] :[L]= Q[GT,NGTL] [AS]. endg)
   = split-tuple(goal GN[GA] is FDL |-{M[MA]}fm F << V3 <- Q[V3,NGTL] if Q[V1,T1,V2,T2,V3] :[L]= GT [AS]. endg)
     cs(goal GN[GA] is FDL |-{M[MA]}fm F << V1 <- Q[GT,V1]   if Q[V1,T1,V2,T2,V3] :[L]= Q[NGTL] [AS]. endg)
     cs(goal GN[GA] is FDL |-{M[MA]}fm F << V2 <- Q[W1,W2]   if Q[W2,T2,V3] :[L]= Q[NGTL]/\ Q[V1,T1,W1] :[L]= GT[AS]. endg)
   if getType(V1) = getType(V2) /\
      getType(V2) = leastSort(M,V3) /\
      leastSort(M,T1) = leastSort(M,T2) /\
      sortLeq(M,leastSort(M,T1),getType(V1)) /\
      leastSort(M,T1) =/= getType(V1) /\
      leastSort(M,GT) = getType(V1) /\
      W1 := qid(string(getName(V2)) + "#1:" + string(getType(V2))) /\
      W2 := qid(string(getName(V2)) + "#2:" + string(getType(V2)))/\
      isCtr(M,getType(V1),Q)/\ isAssoc(M,getType(V1),Q) .
  *** b ***
  ceq cs(goal GN[GA] is FDL |-{M[MA]}fm F if F1 /\ Q[V1,T1,V2,T2,V3] :[L]= Q[GT,NGTL] /\ F2 [AS]. endg)
   = split-tuple(goal GN[GA] is FDL |-{M[MA]} fm F << V1 <- CT        if F1 << V1 <- CT /\ Q[V2,T2,V3] :[L]= Q[NGTL] /\ T1 :[L]= GT /\ F2 << V1 <- CT [AS]. endg)
     cs(goal GN[GA] is FDL |-{M[MA]} fm F << V1 <- Q[GT,V1] if F1 << V1 <- Q[GT,V1] /\ Q[V1,T1,V2,T2,V3] :[L]= Q[NGTL] /\ F2 << V1 <- Q[GT,V1][AS]. endg)
   if getType(V1) = getType(V2) /\
      getType(V2) = leastSort(M,V3) /\
      leastSort(M,T1) = leastSort(M,T2) /\
      sortLeq(M,leastSort(M,T1),getType(V1)) /\
      leastSort(M,T1) =/= getType(V1) /\
      leastSort(M,GT) = leastSort(M,T1) /\
      CT := getID(M,getType(V1),Q)/\
      isCtr(M,getType(V1),Q)/\ isAssoc(M,getType(V1),Q).
  ---
  ceq cs(goal GN[GA] is FDL |-{M[MA]}fm F if Q[V1,T1,V2,T2,V3] :[L]= Q[GT,NGTL] /\ F2 [AS]. endg)
   = split-tuple(goal GN[GA] is FDL |-{M[MA]}fm F <<(V1 <- CT) if Q[V2,T2,V3] :[L]= Q[NGTL] /\ T1 :[L]= GT /\ F2 <<(V1 <- CT)[AS]. endg)
     cs(goal GN[GA] is FDL |-{M[MA]}fm F <<(V1 <- Q[GT,V1]) if Q[V1,T1,V2,T2,V3] :[L]= Q[NGTL] /\ F2 <<(V1 <- Q[GT,V1])[AS]. endg)
   if getType(V1) = getType(V2) /\
      getType(V2) = leastSort(M,V3) /\
      leastSort(M,T1) = leastSort(M,T2) /\
      sortLeq(M,leastSort(M,T1),getType(V1)) /\
      leastSort(M,T1) =/= getType(V1) /\
      leastSort(M,GT) = leastSort(M,T1) /\
      CT := getID(M,getType(V1),Q) /\
      isCtr(M,getType(V1),Q)/\ isAssoc(M,getType(V1),Q) .
  ---
  ceq cs(goal GN[GA] is FDL |-{M[MA]}fm F if F1 /\ Q[V1,T1,V2,T2,V3] :[L]= Q[GT,NGTL] [AS]. endg)
   = split-tuple(goal GN[GA] is FDL |-{M[MA]}fm F << V1 <- CT        if F1 << V1 <- CT /\ Q[V2,T2,V3] :[L]= Q[NGTL] /\ T1 :[L]= GT [AS]. endg)
     cs(goal GN[GA] is FDL |-{M[MA]}fm F <<(V1 <- Q[GT,V1]) if F1 << V1 <- Q[GT,V1] /\ Q[V1,T1,V2,T2,V3] :[L]= Q[NGTL] [AS]. endg)
   if getType(V1) = getType(V2) /\
      getType(V2) = leastSort(M,V3) /\
      leastSort(M,T1) = leastSort(M,T2) /\
      sortLeq(M,leastSort(M,T1),getType(V1)) /\
      leastSort(M,T1) =/= getType(V1) /\
      leastSort(M,GT) = leastSort(M,T1) /\
      CT := getID(M,getType(V1),Q)/\
      isCtr(M,getType(V1),Q)/\ isAssoc(M,getType(V1),Q) .
  ---
  ceq cs(goal GN[GA] is FDL |-{M[MA]}fm F if Q[V1,T1,V2,T2,V3] :[L]= Q[GT,NGTL] [AS]. endg)
   = split-tuple(goal GN[GA] is FDL |-{M[MA]}fm F << V1 <- CT       if Q[V2,T2,V3] :[L]= Q[NGTL] /\ T1 :[L]= GT [AS]. endg)
     cs(goal GN[GA] is FDL |-{M[MA]}fm F << V1 <- Q[GT,V1] if Q[V1,T1,V2,T2,V3] :[L]= Q[NGTL] [AS]. endg)
   if getType(V1) = getType(V2) /\
      getType(V2) = leastSort(M,V3) /\
      leastSort(M,T1) = leastSort(M,T2) /\
      sortLeq(M,leastSort(M,T1),getType(V1)) /\
      leastSort(M,T1) =/= getType(V1) /\
      leastSort(M,GT) = leastSort(M,T1) /\
      CT := getID(M,getType(V1),Q)/\
      isCtr(M,getType(V1),Q)/\ isAssoc(M,getType(V1),Q) .
  *** c ***
  ceq cs(goal GN[GA] is FDL |-{M[MA]}fm F if F1 /\ Q[V1,T1,V2,T2,V3] :[L]= Q[GT] /\ F2 [AS]. endg)
   = split-tuple(goal GN[GA] is FDL |-{M[MA]}fm F if F1 /\ Q[V1,T1,V2,T2,V3] :[L]= GT /\ F2 [AS]. endg)
   if getType(V1) = getType(V2) /\
      getType(V2) = leastSort(M,V3) /\
      leastSort(M,T1) = leastSort(M,T2) /\
      sortLeq(M,leastSort(M,T1),getType(V1)) /\
      leastSort(M,T1) =/= getType(V1) /\
      leastSort(M,GT) = getType(V1)/\
      isCtr(M,getType(V1),Q)/\ isAssoc(M,getType(V1),Q) .
  ---
  ceq cs(goal GN[GA] is FDL |-{M[MA]}fm F if Q[V1,T1,V2,T2,V3] :[L]= Q[GT] /\ F2 [AS]. endg)
   = split-tuple(goal GN[GA] is FDL |-{M[MA]}fm F if Q[V1,T1,V2,T2,V3] :[L]= GT /\ F2 [AS]. endg)
   if getType(V1) = getType(V2) /\
      getType(V2) = leastSort(M,V3) /\
      leastSort(M,T1) = leastSort(M,T2) /\
      sortLeq(M,leastSort(M,T1),getType(V1)) /\
      leastSort(M,T1) =/= getType(V1) /\
      leastSort(M,GT) = getType(V1)/\
      isCtr(M,getType(V1),Q)/\ isAssoc(M,getType(V1),Q) .
  ---
  ceq cs(goal GN[GA] is FDL |-{M[MA]}fm F if F1 /\ Q[V1,T1,V2,T2,V3] :[L]= Q[GT] [AS]. endg)
   = split-tuple(goal GN[GA] is FDL |-{M[MA]}fm F if F1 /\ Q[V1,T1,V2,T2,V3] :[L]= GT [AS]. endg)
   if getType(V1) = getType(V2) /\
      getType(V2) = leastSort(M,V3) /\
      leastSort(M,T1) = leastSort(M,T2) /\
      sortLeq(M,leastSort(M,T1),getType(V1)) /\
      leastSort(M,T1) =/= getType(V1) /\
      leastSort(M,GT) = getType(V1)/\
      isCtr(M,getType(V1),Q)/\ isAssoc(M,getType(V1),Q) .
  ---
  ceq cs(goal GN[GA] is FDL |-{M[MA]}fm F if Q[V1,T1,V2,T2,V3] :[L]= Q[GT] [AS]. endg)
   = split-tuple(goal GN[GA] is FDL |-{M[MA]}fm F if Q[V1,T1,V2,T2,V3] :[L]= GT    [AS]. endg)
   if getType(V1) = getType(V2) /\
      getType(V2) = leastSort(M,V3) /\
      leastSort(M,T1) = leastSort(M,T2) /\
      sortLeq(M,leastSort(M,T1),getType(V1)) /\
      leastSort(M,T1) =/= getType(V1) /\
      leastSort(M,GT) = getType(V1)/\
      isCtr(M,getType(V1),Q)/\ isAssoc(M,getType(V1),Q).
  *** d ***
  ceq cs(goal GN[GA] is FDL |-{M[MA]}fm F if F1 /\ Q[V1,T1,V2,T2,V3] :[L]= Q[GT] /\ F2 [AS]. endg)
   = no-goal
   if getType(V1) = getType(V2) /\
      getType(V2) = leastSort(M,V3) /\
      leastSort(M,T1) = leastSort(M,T2) /\
      sortLeq(M,leastSort(M,T1),getType(V1)) /\
      leastSort(M,T1) =/= getType(V1) /\
      leastSort(M,GT) = leastSort(M,T1)/\
      isCtr(M,getType(V1),Q)/\ isAssoc(M,getType(V1),Q).
  ---
  ceq cs(goal GN[GA] is FDL |-{M[MA]}fm F if Q[V1,T1,V2,T2,V3] :[L]= Q[GT] /\ F2 [AS]. endg)
   = no-goal
   if getType(V1) = getType(V2) /\
      getType(V2) = leastSort(M,V3) /\
      leastSort(M,T1) = leastSort(M,T2) /\
      sortLeq(M,leastSort(M,T1),getType(V1)) /\
      leastSort(M,T1) =/= getType(V1) /\
      leastSort(M,GT) = leastSort(M,T1)/\
      isCtr(M,getType(V1),Q)/\ isAssoc(M,getType(V1),Q).
  ---
  ceq cs(goal GN[GA] is FDL |-{M[MA]}fm F if F1 /\ Q[V1,T1,V2,T2,V3] :[L]= Q[GT] [AS]. endg)
   = no-goal
   if getType(V1) = getType(V2) /\
      getType(V2) = leastSort(M,V3) /\
      leastSort(M,T1) = leastSort(M,T2) /\
      sortLeq(M,leastSort(M,T1),getType(V1)) /\
      leastSort(M,T1) =/= getType(V1) /\
      leastSort(M,GT) = leastSort(M,T1)/\
      isCtr(M,getType(V1),Q)/\ isAssoc(M,getType(V1),Q).
  ---
  ceq cs(goal GN[GA] is FDL |-{M[MA]}fm F if Q[V1,T1,V2,T2,V3] :[L]= Q[GT] [AS]. endg)
   = no-goal
   if getType(V1) = getType(V2) /\
      getType(V2) = leastSort(M,V3) /\
      leastSort(M,T1) = leastSort(M,T2) /\
      sortLeq(M,leastSort(M,T1),getType(V1)) /\
      leastSort(M,T1) =/= getType(V1) /\
      leastSort(M,GT) = leastSort(M,T1)/\
      isCtr(M,getType(V1),Q)/\ isAssoc(M,getType(V1),Q).
endfm

*** ----------------------------------------------------------------------------

fmod CITP/APPLY/TRANS is
  including CITP/APPLY/REDUCE .

  var  L : CITP .
  vars F F1 F2 : Formula{CITP} .
  vars FD FD1 FD2 : FormDecl{CITP} .
  vars H H' FDL FDL1 FDL2 : FormDeclList{CITP} .
  vars C NFDL1 NFDL2 : NeFormDeclList{CITP} .
  var  G : Goal{CITP} .
  vars NGL NGL1 NGL2 : NeGoalList{CITP} .
  vars M M' M1 M2 : Module .
  var  TL : TypeList .
  vars TP TP1 TP2 : Type .
  vars AtS AtS1 AtS2 : AttrSet .
  vars Q GN : Qid .
  vars GA MA : QidList .
  var  ODS : OpDeclSet .
  var  OD : OpDecl .
  vars T T1 T2 T3 T4 : Term .
  var  ST : Sort .
  vars CD CD1 CD2 : Condition .
  vars ECD ECD1 ECD2 : EqCondition .
  vars ES ES1 ES2 : EquationSet .
  vars E E1 E2 : Equation .
  var  RS : RuleSet .
  var  EUT : [UnificationTriple?].
  var  NZ : NzNat .
  var  SB : Substitution .
  var  MD : String .

  *** apply the transitivity tactic  - - - - - - - - - - - - - - - - - - - - - -
  ceq apply(Tactic[L]{trans}, goal GN[GA] is H |-{M[MA]} C endg)
   = goal GN[GA 'trans] is H' |-{M'[MA]} C endg
   if ODS := getOPT(L, M)
      /\ H' := addFD(M, H, comp(M, getFMT(H, ODS), getFMT(H, ODS)))
      /\ M' := addEQ(comp(L, M, getEqs(M), getEqs(M)), M)
      /\ H =/= H' or-else M =/= M' .

  *** getOPT  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
  op getOPT : CITP Module -> OpDeclSet .
  eq getOPT(L, M) = getOPT(L, getOps(M)).

  op getOPT : CITP OpDeclSet -> OpDeclSet .
  eq getOPT(L, (none).OpDeclSet) = (none).OpDeclSet .
  eq getOPT(L, op Q : TP TP -> 'Bool [metadata("transitive") AtS] . ODS)
   = (op Q : TP TP -> 'Bool [AtS] .) getOPT(L, ODS) .
  eq getOPT(L, OD ODS)= getOPT(L, ODS) [owise].

  *** comp  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
  op comp : Module FormDeclList{CITP} FormDeclList{CITP} -> FormDeclList{CITP} .
  ceq comp(M, fm (Q[T1,T2] =[L]= 'true.Bool) [AtS1] .,
              fm (Q[T3,T4] =[L]= 'true.Bool) [AtS2] .)
   = if EUT :: UnificationTriple
     then fm Q[T1 << addX(getLhs(EUT)),
               T4 << addX(getRhs(EUT))] =[L]= 'true.Bool [AtS] .
     else no-fd fi
   if EUT := metaDisjointUnify(M, T2 =? T3, 0, 0)
      /\ MD := "T<" + metadata(AtS1) + ";" + metadata(AtS2) + ">"
      /\ AtS := if metadata(AtS1) =/= "" and-then metadata(AtS2) =/= ""
                then metadata(MD) else none fi .
  eq comp(M, FD1 NFDL1, FD2 NFDL2)
   = comp(M, FD1, FD2) comp(M, FD1, NFDL2)
     comp(M, NFDL1, FD2) comp(M, NFDL1, NFDL2) .
  eq comp(M, FDL1, FDL2) = no-fd [owise] .

  op comp : CITP Module EquationSet EquationSet -> EquationSet .
  ceq comp(L, M, eq Q[T1,T2] = 'true.Bool [AtS1] .,
                 eq Q[T3,T4] = 'true.Bool [AtS2] .)
   = if EUT :: UnificationTriple and-then T =/= 'true.Bool
     then eq T = 'true.Bool [AtS] .
     else none fi
   if EUT := metaDisjointUnify(M, T2 =? T3, 0, 0)
      /\ MD := "T<" + metadata(AtS1) + ";" + metadata(AtS2) + ">"
      /\ AtS := if metadata(AtS1) =/= "" and-then metadata(AtS2) =/= ""
                then metadata(MD) else none fi
      /\ T := red(L, M, Q[T1 << addX(getLhs(EUT)), T4 << addX(getRhs(EUT))]) .
  ceq comp(L, M, E1 ES1, E2 ES2)
   = comp(L, M, E1, E2) comp(L, M, E1, ES2)
     comp(L, M, ES1, E2) comp(L, M, ES1, ES2)
   if ES1 =/= none or-else ES2 =/= none .
  eq comp(L, M, ES1, ES2) = none [owise] .

  *** getFMT  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
  op getFMT : FormDeclList{CITP} OpDeclSet -> FormDeclList{CITP} .
  eq getFMT(no-fd, ODS) = no-fd .
  eq getFMT(fm (Q[T1,T2] =[L]= 'true.Bool) [AtS1] . FDL,
            op Q : TP TP -> 'Bool [AtS2] . ODS)
   = (fm (Q[T1,T2] =[L]= 'true.Bool) [AtS1] .)
     getFMT(FDL, op Q : TP TP -> 'Bool [AtS2] . ODS) .
  eq getFMT(FD FDL, ODS) = getFMT(FDL, ODS) [owise] .

  *** match?  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
  op match? : Module FormDecl{CITP} FormDecl{CITP} -> Bool .
  ceq match?(M, fm (T1 =[L]= T2) [AtS1] .,
                fm (T3 =[L]= T4) [AtS2] .) = true
   if TP1 := getType(metaNormalize(M, T1))
      /\ TP2 := getType(metaNormalize(M, T3))
      /\ sameKind(M, TP1, TP2)
      /\ SB := metaMatch(M, T1, T3, nil, 0)
      /\ T2 << SB = T4 .
  ceq match?(M, fm (T1 =[L]= T2) if F1 [AtS1] .,
                fm (T3 =[L]= T4) if F2 [AtS2] .) = true
   if TP1 := getType(metaNormalize(M, T1))
      /\ TP2 := getType(metaNormalize(M, T3))
      /\ sameKind(M, TP1, TP2)
      /\ SB := metaMatch(M, T1, T3, nil, 0)
      /\ T2 << SB = T4
      /\ F1 << SB = F2 .
  eq match?(M, FD1, FD2) = false [owise] .

  *** addFD  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  op addFD : Module FormDeclList{CITP} FormDeclList{CITP}
    -> FormDeclList{CITP} .
  eq addFD(M, FDL, no-fd) = FDL .
  eq addFD(M, no-fd, FD1) = FD1 .
  eq addFD(M, FD FDL, FD1)
   = if match?(M, FD, FD1) then (FD FDL) else FD addFD(M, FDL, FD1) fi .
  eq addFD(M, FDL, (FD FD1 FDL1)) = addFD(M, addFD(M, FDL, FD), FD1 FDL1) .
endfm

*** ----------------------------------------------------------------------------

fmod CITP/APPLY/IND is
  including  CITP/APPLY .
  protecting CITP/BRIDGE/IND .

  var  L : CITP .
  var  G : Goal{CITP} .
  var  NGL : NeGoalList{CITP} .
  var  GL : GoalList{CITP} .
  vars Q GN QI : Qid .
  vars GA MA : QidList .
  vars M MOP M' : Module .
  vars FD FD' : FormDecl{CITP} .
  var  H : FormDeclList{CITP} .
  vars C1 C2 : NeFormDeclList{CITP} .
  vars F F' : Formula{CITP} .
  var  V : Qid .
  var  NVL : NeQidList .
  var  VS : VariableSet .
  var  TP : Type .
  var  NTPL : NeTypeList .
  vars AtS OAS FAS : AttrSet .
  var  ODS : OpDeclSet .
  var  T : Term .
  var  GT : GroundTerm .
  var  TL : TermList .
  var  NTL : NeTermList .
  var  GTL : GroundTermList .
  var  NGTL : NeGroundTermList .
  var  MD : String .

  *** apply structural induction  - - - - - - - - - - - - - - - - - - - - - - --
  eq apply(Tactic[L]{ind V NVL}, G)
   = apply(Tactic[L]{ind NVL}, apply(Tactic[L]{ind V}, G)) .
  ceq apply(Tactic[L]{ind V},
      goal GN[GA] is H |-{M[MA]} fm forall {V ; VS} F [AtS] . endg)
   = ind-case(V, getCTR(M, getType(V)),
      goal GN[GA qid('ind '`( getName(V))] is
        H |-{M[MA]} fm forall {VS} F [AtS] .
      endg)
   if V in fv(F) /\ getCTR(M, getType(V)) =/= none .

  eq apply(Tactic[L]{ind-schema V NVL}, G)
   = apply(Tactic[L]{ind-schema NVL}, apply(Tactic[L]{ind-schema V}, G)) .
  ceq apply(Tactic[L]{ind-schema V},
      goal GN[GA] is H |-{M[MA]} fm forall {V ; VS} F [AtS] . endg)
   = ind-schema-case(V, getCTR(M, getType(V)),
      goal GN[GA qid('ind-schema '`( getName(V))] is
        H |-{M[MA]} fm forall {VS} F [AtS] .
      endg)
   if V in fv(F) /\ getCTR(M, getType(V)) =/= none .

  *** ind-case  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
  op ind-case : Variable OpDeclSet Goal{CITP} ~> GoalList{CITP} .
  eq ind-case(V, none, G) = no-goal .
  ceq ind-case(V, op Q : nil -> TP [AtS] . ODS, G)
   = goal GN[GA qid(QI '-> Q '`))] is H |-{M[MA]} FD' endg
     ind-case(V, ODS, G)
   if goal GN[GA QI] is H |-{M[MA]} FD endg := G
      /\ MD  := "[" + string(getName(V)) + "<-" + string(Q) + "]"
      /\ FD' := md-update(FD << (V <- const(Q, TP)), MD) .
  ceq ind-case(V, op Q : NTPL -> TP [AtS] . ODS, G)
   = goal GN[GA qid(QI '-> Q '`))] is
       H makeIH(V, GTL, M', FD)
     |-{M'[MA qid('`[ intersperse(';, list-terms(NGTL, M')) '`])]}
       FD'
     endg
     ind-case(V, ODS, G)
   if goal GN[GA QI] is H |-{M[MA]} FD endg := G
      /\ NGTL := TP2C(M, s getLB(getOps(M)), getType(V), NTPL)
      /\ GTL  := TP2C-V(M, s getLB(getOps(M)), getType(V), NTPL)
      /\ GT   := Q[NGTL]
      /\ M'   := addOP(C2ODS(NGTL), M)
      /\ MD   := "[" + string(getName(V)) + "<-" + string(list-terms(GT, M')) + "]"
      /\ FD'  := md-update(FD << (V <- GT), MD) .

  op ind-schema-case : Variable OpDeclSet Goal{CITP} ~> GoalList{CITP} .
  eq ind-schema-case(V, none, G) = no-goal .
  ceq ind-schema-case(V, op Q : nil -> TP [AtS] . ODS, G)
   = goal GN[GA qid(QI '-> Q '`))] is H |-{M[MA]} FD' endg
     ind-schema-case(V, ODS, G)
   if goal GN[GA QI] is H |-{M[MA]} FD endg := G
      /\ MD  := "[" + string(getName(V)) + "<-" + string(Q) + "]"
      /\ FD' := md-update(FD << (V <- const(Q, TP)), MD) .
  ceq ind-schema-case(V, op Q : NTPL -> TP [OAS] . ODS, G)
   = goal GN[GA qid(QI '-> Q '`))] is
       H
     |-{M[MA]}
       FD'
     endg
     ind-schema-case(V, ODS, G)
   if goal GN[GA QI] is H |-{M[MA]} FD endg := G
      /\ (fm F [FAS] .) := FD
      /\ NTL := TP2VL(M, s getLB(F), getType(V), NTPL)
      /\ TL  := TP2VL-V(M, s getLB(F), getType(V), NTPL)
      /\ T   := Q[NTL]
      /\ VS  := vars(NTL)
      /\ F'  := forall {VS} ((F << (V <- T)) if makeIH(V, TL, F))
      /\ MD  := "[" + string(getName(V)) + "<-" + string(list-terms(T, M)) + "]"
      /\ FD' := (fm F' [md-update(FAS, MD)] .) .

  *** makeIH  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
  op makeIH : Variable GroundTermList Module FormDecl{CITP}
    -> FormDeclList{CITP} .
  eq makeIH(V, empty, M, FD)
   = no-fd .
  eq makeIH(V, (GT, GTL), M, FD)
   = md-update(FD << (V <- GT), "[" + string(getName(V)) + "<-" + string(list-terms(GT, M)) + "]")
     makeIH(V, GTL, M, FD) .

  op makeIH : Variable TermList Formula{CITP} -> Formula{CITP} .
  eq makeIH(V, (empty).TermList, F) = true .
  eq makeIH(V, (T, TL), F)
   = if T :: Variable
     then (F << (V <- T)) /\ makeIH(V, TL, F)
     else makeIH(V, TL, F) fi .
endfm

*** ----------------------------------------------------------------------------

fmod CITP/APPLY/INIT is
  including CITP/APPLY/REDUCE .
  including CITP/APPLY/SIMP .
  protecting TERM/VARIANT-UNIFICATION .

  var  L : CITP .
  var  G : Goal{CITP} .
  vars GL GL' : GoalList{CITP} .
  var  NGL : NeGoalList{CITP} .
  vars F F1 F2 : Formula{CITP} .
  vars FD FD' : FormDecl{CITP} .
  vars H H' FDL : FormDeclList{CITP} .
  vars C C' NFDL1 NFDL2 : NeFormDeclList{CITP} .
  vars M M' : Module .
  vars ES ES' : EquationSet .
  vars MS MS' : MembAxSet .
  vars RS RS' : RuleSet .
  var  GN : Qid .
  vars GA MA QIL : QidList .
  var  NVS : NeVariableSet .
  var  SR : String .
  vars K N : Nat .
  var  SB : Substitution .
  var  SBL : SubstList .
  var  NSBL : NeSubstList .
  var  AtS : AttrSet .

  *** apply the initialization tactic  - - - - - - - - - - - - - - - - - - - - -
  *** given metadata and a substitution
  ceq apply(Tactic[L]{init SR, SB}, G)
   = if GL' :: NeGoalList{CITP}
     then goal GN[GA qid('init '`( qid(SR) '`))] is
            H'
          |-{M'[MA qid(QIL)]}
            C
          endg
     else no-goal fi
   if goal GN[GA] is H |-{M[MA]} C endg := G
      /\ MS := getMB(M, SR)
      /\ ES := getEQ(M, SR)
      /\ RS := getRL(M, SR)
      /\ GL' := init(H[SR], SB, init(RS, SB, init(ES, SB, init(MS, SB, G))))
      /\ M' := current-module(GL')
      /\ H' := current-premises(GL')
      /\ GL' == no-goal or-else H' =/= H or-else M' =/= M
      /\ QIL := if M == M' then nil else '`[ qid(SR) '`] fi .

  *** given an index (of a premise) and a substitution
  ceq apply(Tactic[L]{init N, SB}, G)
   = if GL' :: NeGoalList{CITP}
     then goal GN[GA qid('init '`( qid(N) '`))] is H' |-{M[MA]} C endg
     else no-goal fi
   if goal GN[GA] is H |-{M[MA]} C endg := G
      /\ GL' := init(H[N], SB, G)
      /\ H' := current-premises(GL')
      /\ GL' == no-goal or-else H' =/= H .

  *** given only metadata (for now, it acts only on premises)
  ceq apply(Tactic[L]{init SR}, G)
   = if GL' :: NeGoalList{CITP}
     then goal GN[GA qid('init '`( qid(SR) '`))] is H' |-{M[MA]} C endg
     else no-goal fi
   if goal GN[GA] is H |-{M[MA]} C endg := G
      /\ GL' := init(H[SR], G, M)
      /\ H' := current-premises(GL')
      /\ GL' == no-goal or-else H' =/= H .

  *** for all non-executable premises
  ceq apply(Tactic[L]{init-all}, G)
   = if GL' :: NeGoalList{CITP}
     then goal GN[GA 'init-all] is H' |-{M[MA]} C endg
     else no-goal fi
   if goal GN[GA] is H |-{M[MA]} C endg := G
      /\ GL' := init(non-execs(H), G, M)
      /\ H' := current-premises(GL')
      /\ GL' == no-goal or-else H' =/= H .

  *** initialize membership axioms  - - - - - - - - - - - - - - - - - - - - - --
  op init : MembAxSet Substitution Goal{CITP} -> Goal{CITP} .
  ceq init(MS, SB, goal GN[GA] is H |-{M[MA]} C endg)
   = apply(Tactic[CITP]{simp}, goal GN[GA] is H |-{addMB(MS', M)[MA]} C endg)
   if MS' := red(M, addLB(s getLB(getMbs(M)), rmLB(MS)) << SB) \ getMbs(M) .
  eq init(MS, SB, goal GN[GA] is H |-{M[MA]} C endg)
   = goal GN[GA] is H |-{M[MA]} C endg [owise] .

  *** initialize equations  - - - - - - - - - - - - - - - - - - - - - - - - - --
  op init : EquationSet Substitution Goal{CITP} -> Goal{CITP} .
  ceq init(ES, SB, goal GN[GA] is H |-{M[MA]} C endg)
   = apply(Tactic[CITP]{simp}, goal GN[GA] is H |-{addEQ(ES', M)[MA]} C endg)
   if ES' := red(M, addLB(s getLB(getEqs(M)), rmLB(ES)) << SB) \ getEqs(M) .
  eq init(ES, SB, goal GN[GA] is H |-{M[MA]} C endg)
   = goal GN[GA] is H |-{M[MA]} C endg [owise] .

  *** initialize rules  - - - - - - - - - - - - - - - - - - - - - - - - - - - --
  op init : RuleSet Substitution Goal{CITP} -> Goal{CITP} .
  ceq init(RS, SB, goal GN[GA] is H |-{M[MA]} C endg)
   = apply(Tactic[CITP]{simp}, goal GN[GA] is H |-{addRL(RS', M)[MA]} C endg)
   if RS' := red(M, addLB(s getLB(getRls(M)), rmLB(RS)) << SB) \ getRls(M) .
  eq init(RS, SB, goal GN[GA] is H |-{M[MA]} C endg)
   = goal GN[GA] is H |-{M[MA]} C endg [owise] .

  *** initialize formulas  - - - - - - - - - - - - - - - - - - - - - - - - - - -
  op init : FormDeclList{CITP} SubstList GoalList{CITP} -> GoalList{CITP} .
  ceq init(FD FDL, SB, goal GN[GA] is H |-{M[MA]} C endg)
   = init(FDL, SB, apply(Tactic[CITP]{simp}, goal GN[GA] is H FD' |-{M[MA]} C endg))
   if FD' := md-update(md-only(red(M, strip(FD) << SB)), SB, M)
      /\ not occurs(FD', H) .
  eq init(FDL, SB NSBL, GL) = init(FDL, NSBL, init(FDL, SB, GL)) .
  eq init(FDL, SBL, GL) = GL [owise] .

  op init : FormDeclList{CITP} GoalList{CITP} Module -> GoalList{CITP} .
  eq init(no-fd, GL, M) = GL .
  eq init(FDL, no-goal, M) = no-goal .
  ceq init(FD FDL, NGL, M) = init(FDL, init(FD, SBL, head-goal(NGL)), M)
   if (fm F1 if F2 [AtS] .) := strip(FD)
      /\ SBL := solve(unif-problem(F2), variant-module(M)) .
  eq init(FD FDL, NGL, M) = init(FDL, NGL, M) [owise] .
endfm

*** ----------------------------------------------------------------------------

fmod CITP/APPLY/SUBST is
  including CITP/APPLY .

  var  L : CITP .
  var  F : Formula{CITP} .
  vars FD FD' : FormDecl{CITP} .
  var  H : FormDeclList{CITP} .
  vars C C' NFDL NFDL' : NeFormDeclList{CITP} .
  var  M : Module .
  var  GN : Qid .
  vars GA MA : QidList .
  vars VS VS' : VariableSet .
  vars NVS NVS' : NeVariableSet .
  vars SB SB' : Substitution .
  var  AtS : AttrSet .

  *** apply the substitution tactic  - - - - - - - - - - - - - - - - - - - - - -
  ceq apply(Tactic[L]{subst SB}, goal GN[GA] is H |-{M[MA]} C endg)
   = goal GN[GA 'subst] is H |-{M[MA]} C' endg
   if C' := sbt(C, SB) /\ C' =/= C .

  op sbt : FormDeclList{CITP} Substitution -> FormDeclList{CITP} .
  eq sbt(no-fd, SB) = no-fd .
  ceq sbt(fm exists {NVS} F [AtS] ., SB)
   = (fm forall {VS} exists {VS'} (F << SB') [AtS] .)
   if VS := fv(exists {NVS}  F)
      /\ SB' := SB ^ NVS
      /\ VS' := vars-right(SB') - VS .
  eq sbt(fm forall {NVS} exists {NVS'} F [AtS] ., SB)
   = sbt(fm exists {NVS'} F [AtS] ., SB) .
  eq sbt(FD, SB) = FD [owise] .
  ceq sbt(NFDL FD, SB) = if occurs(FD', NFDL') then NFDL' else NFDL' FD' fi
   if NFDL' := sbt(NFDL, SB)
      /\ FD' := sbt(FD, SB) .
endfm

*** ----------------------------------------------------------------------------

fmod CITP/APPLY/PULL is
  including CITP/APPLY .

  var  L : CITP .
  var  GN : Qid .
  vars GA MA : QidList .
  var  H : FormDeclList{CITP} .
  vars C NFDL : NeFormDeclList{CITP} .
  var  M : Module .
  var  SR : String .

  *** apply the pull tactic  - - - - - - - - - - - - - - - - - - - - - - - - - -
  ceq apply(Tactic[L]{pull SR}, goal GN[GA] is H |-{M[MA]} C endg)
   = goal GN[GA qid('pull '`( qid(SR) '`))] is
       H NFDL
     |-{rmRL(rmMB(rmEQ(M, SR), SR), SR)[MA]}
       C
     endg
   if NFDL := eq2fm(L, getEQ(M, SR))
              mb2fm(L, getMB(M, SR))
              rl2fm(L, getRL(M, SR)) .
endfm

*** ----------------------------------------------------------------------------

fmod CITP/APPLY/PUSH is
  including CITP/APPLY .

  var  L : CITP .
  var  G : Goal{CITP} .
  vars QI GN : Qid .
  vars GA GA' MA MA' : QidList .
  var  F : Formula{CITP} .
  var  FD : FormDecl{CITP} .
  vars H H' FDL : FormDeclList{CITP} .
  var  C : NeFormDeclList{CITP} .
  vars M M' : Module .
  var  ES : EquationSet .
  var  MS : MembAxSet .
  var  RS : RuleSet .
  var  SR : String .
  vars N N' : Nat .
  var  AtS : AttrSet .

  *** apply the push tactic  - - - - - - - - - - - - - - - - - - - - - - - - - -
  ceq apply(Tactic[L]{push SR}, goal GN[GA] is H |-{M[MA]} C endg)
   = goal GN[GA qid('push '`( qid(SR) '`))] is
       rm(H, SR)
     |-{M'[MA qid('`[ qid(SR) '`])]}
       C
     endg
   if ES := fm2eq(H[SR]) or-else none
      /\ MS := fm2mb(H[SR]) or-else none
      /\ RS := fm2rl(H[SR]) or-else none
      /\ ES =/= none or-else MS =/= none or-else RS =/= none
      /\ M' := addRL(RS, addMB(MS, addEQ(ES, M))) .

  ceq apply(Tactic[L]{push N}, goal GN[GA] is H |-{M[MA]} C endg)
   = goal GN[GA qid('push '`( qid(N) '`))] is
       rm(H, N)
     |-{M'[MA qid('`[ qid(N) '`])]}
       C
     endg
   if ES := fm2eq(H[N]) or-else none
      /\ MS := fm2mb(H[N]) or-else none
      /\ RS := fm2rl(H[N]) or-else none
      /\ ES =/= none or-else MS =/= none or-else RS =/= none
      /\ M' := addRL(RS, addMB(MS, addEQ(ES, M))) .

  ceq apply(Tactic[L]{push-all}, goal GN[GA] is H |-{M[MA]} C endg)
   = goal GN[GA 'push-all] is H' |-{M'[MA']} C endg
   if goal GN[GA'] is H' |-{M'[MA']} C endg
         := push(H, 0, goal GN[GA] is no-fd |-{M[MA]} C endg)
      /\ H' =/= H or-else  M' =/= M .

  op push : FormDeclList{CITP} Nat Goal{CITP} -> Goal{CITP} .
  eq push(no-fd, N, G) = G .
  ceq push(FD FDL, N, goal GN[GA] is H |-{M[MA]} C endg)
   = push(FDL, N', goal GN[GA] is H |-{M'[MA qid('`[ QI '`])]} C endg)
   if (fm F [AtS] .) := FD
      /\ F is executable
      /\ not circular(M, F)
      /\ AtS is nonexec-free
      /\ ES := fm2eq(FD) or-else none
      /\ MS := fm2mb(FD) or-else none
      /\ RS := fm2rl(FD) or-else none
      /\ ES =/= none or-else MS =/= none or-else RS =/= none
      /\ SR := metadata(AtS)
      /\ QI := if SR == "" then qid(N) else qid(SR) fi
      /\ M' := addRL(RS, addMB(MS, addSeqRedEQ(ES, M)))
      /\ N' := if SR == "" then s N else N fi .
  eq push(FD FDL, N, goal GN[GA] is H |-{M[MA]} C endg)
   = push(FDL, N, goal GN[GA] is H FD |-{M[MA]} C endg) [owise] .
endfm

*** ----------------------------------------------------------------------------

fmod CITP/APPLY/SELECT is
  including CITP/APPLY .

  var L : CITP .
  var GL : GoalList{CITP} .
  var N : Nat .

  *** apply the select tactic  - - - - - - - - - - - - - - - - - - - - - - - - -
  eq apply(Tactic[L]{select N}, GL) = (GL[N]) rm(GL, N) .
endfm

*** ----------------------------------------------------------------------------

fmod CITP/APPLY/PASS is
  including CITP/APPLY .

  var L : CITP .
  var GL : GoalList{CITP} .

  *** apply the pass tactic  - - - - - - - - - - - - - - - - - - - - - - - - - -
  eq apply(Tactic[L]{pass}, GL) = no-goal .
endfm

*** ----------------------------------------------------------------------------

fmod CITP/APPLY/ALL is
  including CITP/APPLY/SPLIT .
  including CITP/APPLY/@CRT .
  including CITP/APPLY/SIMP .
  including CITP/APPLY/RED .
  including CITP/APPLY/IMP .
  including CITP/APPLY/CONJ .
  including CITP/APPLY/DISJ .
  including CITP/APPLY/TC .
  including CITP/APPLY/SK .
  including CITP/APPLY/CA .
  including CITP/APPLY/CS .
  including CITP/APPLY/TRANS .
  including CITP/APPLY/IND .
  including CITP/APPLY/INIT .
  including CITP/APPLY/SUBST .
  including CITP/APPLY/PULL .
  including CITP/APPLY/PUSH .
  including CITP/APPLY/SELECT .
  including CITP/APPLY/PASS .
endfm

********************************************************************************
