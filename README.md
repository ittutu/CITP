# CITP (The Constructor-based Inductive Theorem Prover)

The Constructor-based Theorem Prover (CITP) is a tool for proving inductive
properties of software systems specified with constructor-based logics. The
present document describes the main commands supported by CITP.

## Installing the CITP

The CITP uses [Maude](http://maude.cs.illinois.edu/w/index.php?title=The_Maude_System)
as rewriting engine. Hence, the first step is to download and install the Maude
system following the instructions [here](http://maude.cs.illinois.edu/w/index.php?title=Maude_download_and_installation).
We present a basic introduction to Maude [here](#maude).

Once Maude has been installed (we assume a **maude** command for executing it),
we can download the CITP repository by using

```
git clone https://github.com/ittutu/CITP
```

This command creates a folder **CITP** in our computer. Among others, it contains
the subfolder **Tool**, which contains the source code of the tool in the
**citp.maude** file, and the subfolder **Examples**, with several examples that can
be executed by users to test the tool. For example, to run the **TAS** example we
should do as follows:

```
maude Tool/citp.maude

cd CITP/Examples/tas_exercise
load tas.maude

select #CITP# .
loop init .
```

The first command starts Maude and loads the CITP. The second command sets the current
folder as the one containing the tas example, while the third one loads the module into
Maude. This module contains the simple mutual exclusion protocol *test&set*, which we
will explain in detail later.
Finally, the last two commands select the tool and initiate it, so we can start
introducing commands.

## Using the CITP

In the following we present how to introduce and prove goals in CITP.
It is important to note that all the commands presented here must be introduced in
the tool enclosed in parentheses, so they can be parsed by the CITP.

### Goals

All proofs start by introducing a goal. In CITP, goals are sets of sentences related
to a given module. The syntax for introducing goals is

```
goal MOD-NAME |-
SENT1 ;
...
SENTn ;
```

where `MOD-NAME` is the name of the module where the proof takes place and
`SENT1` ... `SENTn` are the sentences the goal is composed of. These sentences
can be either equations, membership axioms, and rewrite rules.

### Proof tactics

We present next the tactics available in CITP. In general, we will not apply
single tactics but tactic lists of the form **(tc1 ... tcn)**, where each **tci**
is a single tactic.

Note that CITP handles
a set of goals of the form **(goal M |- SS)**, with **M** a module and **SS** a
set of sentences. In contrast to other provers, CITP does not keep a tree structure
and list of tactics will be applied to all goals.

If the user wants to apply the tactic list only to the current goal then the
command **(. tc1 ... tcn)** can be used. Moreover, we can change the current goal
with **(select N)**, which selects the **N**th goal as current one.

#### General proof tactics

The general proof tactics, described in the table below, are sound for all
specifications. It is important to note that

Some details about these commands are:

* *Simultaneous induction* has syntax `ind on V:Sort`, for `V:Sort` a variable
appearing in the goal. The cases are generated by using the operators marked with
the **ctor** atribute in the specification.
* The *theorem of constants* replaces all variables by fresh constants and
splits the sentences in the same goal in several goals.
* *Case analysis* splits the goals by using the conditions of conditional
sentences. It assumes the conditions are disjointly true and the left-hand
side of the sentences is equal.
* *Implication* adds the conditions in the sentences of the goal to the module.
* *Reduction* reduces by rewriting both sides of the current goal.
* *Initialization* has syntax `init sen by sub`, for a sentence `sen` and a
substitution `sub`, gives concrete values to the variables in the sentence.
* *Critical pairs left* has syntax **(cp-l sentence1 >< sentence2)** tries to unify
a subterm of **sentence1** with the left-hand side of **sentence2**.
**cp-r** works analogously for the right-hand side.

| Tactic                 |     Command       |
|------------------------|-------------------|
| Simultaneous induction | **ind on**        |
| Theorem of constants   | **tc**            |
| Case analysis          | **ca**            |
| Implication            | **imp**           |
| Reduction              | **red**           |
| Initialisation         | **init**          |
| Critical pairs left    | **cp-l**          |
| Critical pairs right   | **cp-r**          |

#### Specific proof tactics

The specific proof tactics, listed in the table below, are sound for initial data
types that are often used in applications such as sequences/lists, sets and pairs
as long as they are protected.

It is important to note that these tactics are designed for goals consisting of a
specification and a single formula: **ca, tc, imp, red, cs, pair**. However, if one
of these tactics is applied to a goal of the form **M |- {E1,...,En}**, the goal
is decomposed into a list of subgoals **(M |- E1), ..., (M |- En)** and then the
tactic is applied to each goal **M |- Ei**.

| Tactic                               | Command  |
|--------------------------------------|----------|
| Induction based on membership axioms | **indx** |
| Case analysis for sequences and sets | **cs**   |
| Pair                                 | **pair** |

#### Interface commands

In addition to the commands for developing the proof, CITP provides commands
for interacting with the interface, as shown by the table below.

| Command          | Description                                                                      |
|------------------|----------------------------------------------------------------------------------|
| **rollback**     | Returns the proof process to the state before applying the last list of tactics. |
| **show goals**   | Displays the goals to discharge.                                                 |
| **show proof**   | Shows the sequence of lists of tactics applied                                   |
| **redTerm t**    | Reduces the term **t** to its normal form  w.r.t. the current module.            |

## TAS example

We present here a simple example to give users a flavor of how to specify systems
in Maude and prove properties of them with the CITP. First, we describe how to specify
the TAS protocol in Maude. Then, we prove properties on it with CITP. The specification
of the protocol and the proofs are available [here](https://github.com/ittutu/CITP/tree/master/Examples/tas_exercise).

### Maude

We first define the `LABEL` module to specify the possible states of processes:
in remainder  section (label `cs`) or in critical section (label `cs`).
These operators are *constructors* (attribute `ctor`) of the sort `Label`.
We also define a predicate `_~_` for checking whether two labels are equal:

```
fmod LABEL is
 sort Label .

 ops rs cs : -> Label [ctor] .
 op _~_ : Label Label -> Bool [comm] .
 eq (L:Label ~ L:Label) = true .
 eq (rs ~ cs) = false .
endfm
```

The theory `PID` defines generic process identifiers
(sort `Pid`) and the same equality predicate for them:

```
fth PID is inc BOOL .
 sort Pid .
 op _~_ : Pid Pid -> Bool [comm] .
 eq (P:Pid ~ P:Pid) = true .
endfth
```

The module `STATUS` specifies the states of the lock, which can be
either `open` or `close`, constructors of the sort `Status`. We also
define in this case the equality operator:

```
fmod STATUS is
 sort Status .
 ops open close : -> Status [ctor] .
 op _~_ : Status Status -> Bool [comm] .
 eq (L:Status ~ L:Status) = true .
 eq (open ~ close) = false .
endfm
```

The module `TAS` is in charge of defining the behavior of the system. It is
parameterized by the theory `PID` above, imports the rest of modules, and
defines a sort `Sys` for the system:

```
fmod TAS{X :: PID} is
 pr LABEL .
 pr STATUS .
 sort Sys .
```

We define next the constructors for the system. It can be in the initial
state (`init`), a process identifier can be entering the critical section
(`enter`) or leaving it (`leave`):

```
 --- any initial state
 op init : -> Sys [ctor] .
 --- transitions
 op enter : Sys X$Pid -> Sys [ctor] .
 op leave : Sys X$Pid -> Sys [ctor] .
```

We also define *observations* to observe the state of the system in
a particular moment. The observation `pc` returns the label associated
to the `Pid` given as argument, while `lock` returns the status of the
lock:

```
 op pc   : Sys X$Pid -> Label .
 op lock : Sys -> Status .
```

We define some variables and start specifying the observations for the initial
state. In this case all proceses are in the remainder section and the lock is open.
Note that we use the attribute `metadata` to assign names to these equations.
These names can be used later when proving properties with CITP:

```
 vars I J : X$Pid .
 var  S : Sys .

 eq pc(init,I) = rs   [metadata "CA-1"] .
 eq lock(init) = open [metadata "CA-A"] .
```

We define next observations for `enter`. We define `pc` first:
* The equation `CA-PCE1` indicates that, if the lock is open and the process is in the
remainder section, then it can go into the critical section.
* In any other case we need a recursive call:
	+ Equation `CA-PCE2` is applied when the processes are different.
	+ Equation `CA-PCE3` is applied when the process is not in the remainder section.
	+ Equation `CA-PCE4` is applied when the lock is closed.

Then, we define the equations for `lock`:
* The equation `CA-LE1` indicates the lock changes to `close` when a process enters the
critical section.
* Otherwise, we recursively traverse the system:
 + The equation `CA-LE2` is applied when the process is not in the remainder section.
 + The equation `CA-LE3` is applied when the lock was not `open`.

```
 ceq pc(enter(S,I),J) = cs      if J = I /\ pc(S,I) = rs /\ lock(S) = open [metadata "CA-PCE1"].
 ceq pc(enter(S,I),J) = pc(S,J) if (J ~ I) = false                         [metadata "CA-PCE2"].
 ceq pc(enter(S,I),J) = pc(S,J) if (pc(S,I) ~ rs) = false                  [metadata "CA-EPCE3"].
 ceq pc(enter(S,I),J) = pc(S,J) if (lock(S) ~ open) = false                [metadata "CA-PCE4"].

 ceq lock(enter(S,I)) = close   if pc(S,I) = rs /\ lock(S) = open [metadata "CA-LE1"].
 ceq lock(enter(S,I)) = lock(S) if (pc(S,I) ~ rs) = false         [metadata "CA-LE2"].
 ceq lock(enter(S,I)) = lock(S) if (lock(S) ~ open) = false       [metadata "CA-LE3"].
```

Finally, we define the behavior of the observations for `leave`. For `pc`
we have:
* The equation `CA-PCV1` indicates that the process goes to the remainder section
when it was in the critical section.
* Otherwise, we recursively check the state:
 + The equation `CA-PCV2` is applied when we are looking for a different process.
 + The equation `CA-PCV3` is applied when it was not in the critical section.

Regarding `lock`, we have the following equations:
* The equation `CA-LL1` indicates that the lock opens when the process goes
out of the critical section.
* Otherwise, the equation `CA-LL2` recursively checks the system:

```
 ceq pc(leave(S,I),J) = rs      if J = I /\ pc(S,I) = cs [metadata "CA-PCV1"].
 ceq pc(leave(S,I),J) = pc(S,J) if (J ~ I) = false       [metadata "CA-PCV2"].
 ceq pc(leave(S,I),J) = pc(S,J) if (pc(S,I) ~ cs) = false[metadata "CA-PCV3"].

 ceq lock(leave(S,I)) = open if pc(S,I) = cs              [metadata "CA-LL1"].
 ceq lock(leave(S,I)) = lock(S) if (pc(S,I) ~ cs) = false [metadata "CA-LL2"].
endfm
```


### CITP

We show now how to prove some properties on this protocol. In particular, we
prove that the lock is closed when there is a process in the critical section
(first equation of the goal) and that, if two processes are in the critical
section at the same time, it is because they are the same process (second equation):

```
(goal TAS |-
ceq lock(S:Sys)= close if pc(S:Sys,I:X$Pid)= cs[nonexec];
ceq I:X$Pid = J:X$Pid if pc(S:Sys,I:X$Pid)= cs /\ pc(S:Sys,J:X$Pid)= cs[nonexec];)
```

We start the proof by applying induction on `S:Sys` and reducing:

```
(ind on S:Sys red)
```

When this command is applied we obtain 3 new goals, one corresponding to each
constructor for `Sys`. For example, CITP generates the following goal for `leave`:

```
====================================================
--------------------- Goal: 1 ---------------------
< fmod TAS is
sorts Bool Label Status Sys X$Pid .
op x#1 : -> Sys[metadata "induction-constant"].
op z#2 : -> X$Pid[metadata "induction-constant"].
ceq I:X$Pid = J:X$Pid if pc(x#1,I:X$Pid)= cs /\ pc(x#1,J:X$Pid)= cs[metadata "1" metadata "leave" nonexec].
ceq lock(x#1)= close if pc(x#1,I:X$Pid)= cs[metadata "2" metadata "leave" nonexec].
. . .
endfm,
ceq I:X$Pid = J:X$Pid if pc(leave(x#1,z#2),I:X$Pid)= cs /\ pc(leave(x#1,z#2),J:X$Pid)= cs[nonexec];
ceq lock(leave(x#1,z#2))= close if pc(leave(x#1,z#2),I:X$Pid)= cs[nonexec]; >
------------------- Current goal -------------------
====================================================
```

Note how the goals are listed after the current module, where only equations
and operators generated by CITP are shown for the sake of readability.

We start proving the goal for `init`, so we select the appropriate goal:

```
(select 2)
```

which looks like follows:

```
< fmod TAS is
sorts Bool Label Status Sys X$Pid .
. . .
endfm,
ceq I:X$Pid = J:X$Pid if rs = cs /\ rs = cs[nonexec];
ceq open = close if rs = cs[nonexec]; >
```

This goal is proven by first applying the theorem of constants and
implication:

```
(. tc red imp red)
```

once this tactic list is introduced, we obtain a couple of goals
that looks like this:

```
< fmod TAS is
sorts Bool Label Status Sys X$Pid .
eq rs = cs [metadata "1"].
. . .
endfm,
eq open = close [nonexec]; >
```

We know that `rs` and `cs` are different and hence we have a
contradiction. We use it to prove the property with the `cp-l`
command:

```
(cp-l eq(rs ~ cs)= false ; >< eq rs = cs ;)
```

We continue the proof by applying the theorem of constants,
case analysis, and implication:

```
(tc red ca-1 red ca red imp red)
```

This tactic list generates 20 goals, being the first one of them:

```
< fmod TAS is
sorts Bool Label Status Sys X$Pid .
op I#3 : -> X$Pid[metadata "new"].
op x#1 : -> Sys[metadata "induction-constant"].
op z#2 : -> X$Pid[metadata "induction-constant"].
eq I#3 ~ z#2 = false[metadata "3"].
eq cs ~ pc(x#1,z#2)= false[metadata "4"].
eq pc(x#1,I#3)= cs[metadata "5"].
ceq I:X$Pid = J:X$Pid if pc(x#1,I:X$Pid)= cs /\ pc(x#1,J:X$Pid)= cs[metadata "1" metadata "leave" nonexec].
ceq lock(x#1)= close if pc(x#1,I:X$Pid)= cs[metadata "2" metadata "leave" nonexec].
. . .
endfm,
eq lock(x#1)= close[nonexec]; >
```

We see that we have some free variables in the equations labeled as
`1` and `2`, so we can give them concrete values with the `init` command:

```
(init 2 by I:X$Pid <- I#3 red)

(init 1 by I:X$Pid <- I#3 ; J:X$Pid <- z#2 red)
```

These instantiations discharge 7 goals. The first goal that was not discharged is:

```
< fmod TAS is
sorts Bool Label Status Sys X$Pid .
op I#3 : -> X$Pid[metadata "new"].
op x#1 : -> Sys[metadata "induction-constant"].
op z#2 : -> X$Pid[metadata "induction-constant"].
eq I#3 = z#2[metadata "7"].
eq I#3 ~ z#2 = false[metadata "3"].
eq lock(x#1)= close[metadata "6"].
eq pc(x#1,I#3)= cs[metadata "5"].
eq pc(x#1,z#2)= cs[metadata "4"].
ceq I:X$Pid = J:X$Pid if pc(x#1,I:X$Pid)= cs /\ pc(x#1,J:X$Pid)= cs[metadata "1" metadata "leave" nonexec].
ceq lock(x#1)= close if pc(x#1,I:X$Pid)= cs[metadata "2" metadata "leave" nonexec].
. . .
endfm,
eq open = close[nonexec]; >
```

We notice that equations `3` and `7` are a contradiction, so we can join
critical pairs again to discharge this goal:

```
(. cp-l 3 >< 7)
```

The rest of goals are easily discharged following the same ideas we have shown
above:

```
(. cp-l eq(rs ~ cs)= false ; >< eq rs = cs ;)
(init 1 by I:X$Pid <- I#3 ; J:X$Pid <- J#4 red)
(. cp-l eq(open ~ close)= false ; >< eq open = close ;)
(. init 2 by I:X$Pid <- J#4)
(. cp-l eq(open ~ close)= false ; >< eq open = close ;)
```

## References
* Michel Bidoit, Rolf Hennicker:
[Constructor-based observational logic](https://doi.org/10.1016/j.jlap.2005.09.002).
J. Log. Algebr. Program. 67(1-2): 3-51 (2006).
* Michel Bidoit, Rolf Hennicker, Alexander Kurz:
[Observational logic, constructor-based logic, and their duality](https://doi.org/10.1016/S0304-3975(02)00865-4).
Theor. Comput. Sci. 3(298): 471-510 (2003).
* Kokichi Futatsugi, Daniel Gaina, Kazuhiro Ogata:
[Principles of proof scores in CafeOBJ](https://doi.org/10.1016/j.tcs.2012.07.041).
Theor. Comput. Sci. 464:90-112 (2012).
* Daniel Gaina, Kokichi Futatsugi, Kazuhiro Ogata:
[Constructor-based Logics](https://doi.org/10.3217/jucs-018-16-2204).
J. UCS 18(16): 2204-2233 (2012).
* Daniel Gaina:
[Interpolation in logics with constructors](https://doi.org/10.1016/j.tcs.2012.12.002).
Theor. Comput. Sci. 474: 46-59 (2013).
* Daniel Gaina, Kokichi Futatsugi:
[Initial semantics in logics with constructors](https://doi.org/10.1093/logcom/exs044).
J. Log. Comput. 25(1): 95-116 (2015)
* Daniel Gaina, Zhang Min, Yuki Chiba, Yasuhito Arimoto:
[Constructor-based Inductive Theorem Prover](https://doi.org/10.1007/978-3-642-40206-7_26).
CALCO 2013, Warsaw, Poland, September 3-6 (2013).
* Daniel Gaina, Dorel Lucanu, Kazuhiro Ogata, Kokichi Futatsugi:
[On Automation of OTS/CafeOBJ Method](https://doi.org/10.1007/978-3-642-54624-2_29).
Specification, Algebra, and Software: 578-602 (2014).
